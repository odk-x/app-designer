
<html>
<!--
This file is automatically generated and all changes will be overwritten



































































































-->
    <head>
        <meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <script type="text/javascript" src="/coldchain/system/js/odkCommon.js"></script>
        <script type="text/javascript" src="/coldchain/system/js/odkData.js"></script>
        <script type="text/javascript" src="formgen_common.js"></script>
        <script type="text/javascript" src="/coldchain/system/tables/js/odkTables.js"></script>
        <style>
body {
	font-family: Roboto;
}
#edit, #delete {
	float: right;
}
#header {
	text-align: center;
	font-size: 150%;
	min-height: 1.5em;
}
#back {
	float: left;
}
input, button {font-size: 16px;}

#rest {
	display: none;
}
body {
	font-family: arial;
}
.h4-wrapper {
	margin-top: 1.5em;
	text-align: center;
	display: block;
	/* wrapper height 45px, text height 25px */
	height: 45px;
	line-height: 45px; /* TEST for vertical center */
	background: linear-gradient(indianred, lightcoral);
}
h4 {
	display: inline-block;
	height: 25px;
	margin: 0px 0px;
	color: #eeeeee;
}
.main-col-wrapper {
	background: repeating-radial-gradient(mediumaquamarine, lightseagreen, teal);
	box-shadow: 0 2px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
	color: white;
	border-bottom: none !important;
	margin-top: 3.5em;
	text-align: center;
	font-size: 150%;
	/*line-height: 1.5em;*/
	padding-top: 1em;
	padding-bottom: 1em;
}
@media screen and (min-width: 480px) {
	.main-col-wrapper {
		/*line-height: 4em;*/
	}
}

button {
	/*margin-top: -4em;*/
	padding: 1em 10%;
	border: 2px solid teal;
	border-radius: 10px;
	background-color: lightsegreen;
}
.li-inner {
	border-bottom: 2px solid teal
}
li {
	/*margin-top: 10px;*/
	margin-bottom: 20px;
	padding-bottom: 5px;
	break-inside: avoid-column;
	-webkit-column-break-inside: avoid;
	display: block;
}

@media screen and (min-width: 480px) {
	ul {
		columns: 2;
		-webkit-columns: 2;
	}
}
ul {
	list-style-type: none;
	padding-left: 20px;
	padding-right: 20px;
}
.main-col-wrapper > div {
	border-bottom-style: none;
}
#edit {
	margin-left: 8px;
}
#main-col {
	display: none;
}

        </style>
        <script>
// A map of table ids to their instance columns (or _id if we couldn't pull it)
var display_cols = {"refrigerators": "refrigerator_id", "health_facility": "facility_name", "m_logs": "date_serviced", "refrigerator_types": "catalog_id"}
// List of tables to edit with formgen. If a table isn't found in this list, we edit it with survey instead
var allowed_tables = ["refrigerators", "health_facility", "m_logs", "refrigerator_types"];
var table_id = null;
var row_id = null;
// a map you can override in customJsOnload that dictates which columns get printed and how they get printed
// e.g. pretty printed or not, or you can give a callback for a column that returns what should get printed
// If you leave it as this, it will just print every column as not pretty printed no matter what
// If you set it, only the things you put in it will get set. For what to put in it, see README.md
var colmap = [];
// The main column. We'll try and get this from display_cols unless you override it in customJsOl
var main_col = "";
// Used so we only have to query the database once, just save the result object
var cached_d = null;
// Global join and select arguments, see README
var global_join = "";
var global_which_cols_to_select = "*"
// Function called on page load, tries to pull table id and row id from url hash, sets up doAction listener so we'll reload
// when the user comes back from editing the row
var ol = function ol() {
    var hash = document.location.hash.substr(1);
    if (hash.length > 0 && hash.indexOf("/") > 0) {
        table_id = hash.split("/")[0]
        row_id = hash.split("/")[1]
    }
    // BEGIN CONFIG
    var generic_callback = function generic_callback(e, c, d, which, pretty, optional_col_name) {
	if (optional_col_name == null || optional_col_name == undefined || typeof(optional_col_name) != "string") optional_col_name = displayCol(which, d.getMetadata())
	wrapper = function(i) { return i; };
	if (pretty) wrapper = function(i) { return window.pretty(i.toString()); };
	document.getElementById("inject-" + which).innerHTML = "<b>" + optional_col_name + "</b>: " + wrapper(c);
	document.getElementById("inject-" + which).classList.add("li-inner");
}
var build_generic_callback = function build_generic_callback(which, pretty, optional_col_name) {
	return function _generic_callback_wrapper(e, c, d) {
		if (typeof(pretty) == "string") {
			c = c.toString() + pretty;
			pretty = false;
		}
		if (typeof(pretty) == "function") {
			c = pretty(c)
			pretty = false;
		}
		return generic_callback(e, c, d, which, pretty, optional_col_name);
	}
}


    var model_callback = function model_callback(e, c, d) {
        var btn = document.getElementById("open_model");
        var model = d.getData(0, "catalog_id"); // from join, not actually the model id
        var model_row_id = d.getData(0, "model_row_id");
        btn.disabled = false;
        btn.addEventListener("click", function() {
            odkTables.openDetailView(null, "refrigerator_types", model_row_id);
        });
        build_generic_callback("model_id", true)(e, c, d)
        return "";
    }
    var hf_callback = function hf_callback(e, c, d) {
        console.log(d.getData(0, "facility_name"));
        var btn = document.getElementById("open_hf");
        var hf = d.getData(0, "facility_name"); // from join, not actually the hf id
        var hf_row_id = d.getData(0, "facility_row_id");
        btn.disabled = false;
        btn.addEventListener("click", function() {
            odkTables.openDetailView(null, "health_facility", hf_row_id, "config/assets/aa_health_facility_detail.html#health_facility/" + hf_row_id);
        });
        build_generic_callback("facility_name", true, "Facility")(e, c, d)
        document.getElementById("add_m_log").disabled = false;
        var defaults = {"refrigerator_id": d.getData(0, "refrigerator_id"), "date_serviced": odkCommon.toOdkTimeStampFromDate(new Date())};
        document.getElementById("add_m_log").addEventListener("click", function add_m_log() {
            if (allowed_tables.indexOf("m_logs") >= 0) {
                var id = newGuid();
                odkData.addRow("m_logs", defaults, id, function() {
                    // Escape the LIMIT 1
                    odkData.arbitraryQuery("m_logs", "UPDATE m_logs SET _savepoint_type = ? WHERE _id = ?;--", ["INCOMPLETE", id], 100, 0, function success(d) {
                        odkTables.launchHTML({}, "config/assets/formgen/m_logs#" + id);
                    }, null);
                });
            } else {
                odkTables.addRowWithSurvey({}, "m_logs", "m_logs", null, defaults);
            }
        });
        // UNTESTED
        document.getElementById("view_m_log").disabled = false;
        document.getElementById("view_m_log").addEventListener("click", function add_m_log() {
            odkTables.launchHTML(null, clean_href() + "config/assets/aa_m_logs_list.html#m_log/refrigerator_id = ?/" + d.getData(0, "refrigerator_id"));
        });

        return "";
    }

    allowed_tables = ["m_logs"];
    main_col = "";
    global_join = "refrigerator_types ON refrigerators.model_row_id = refrigerator_types._id JOIN health_facility ON refrigerators.facility_row_id = health_facility._id"
    global_which_cols_to_select = "*"
    var subquery = "(SELECT date_serviced FROM m_logs WHERE m_logs.refrigerator_id = refrigerators.refrigerator_id AND m_logs._savepoint_type != 'INCOMPLETE' ORDER BY date_serviced DESC LIMIT 1)"
    global_which_cols_to_select = global_which_cols_to_select.concat(", (CASE WHEN "+subquery+" IS NOT NULL THEN "+subquery+" ELSE 'No Records' END) as date_serviced")
    colmap = [
        ["facility_name", hf_callback],
        ["year", build_generic_callback("year", true, "Year Installed")],
        ["working_status", build_generic_callback("working_status", true, "Status")],
        ["reason_not_working", build_generic_callback("reason_not_working", true)],
        ["model_row_id", model_callback],
        ["tracking_id", build_generic_callback("tracking_id", false, "Tracking Number")],
        ["voltage_regulator", build_generic_callback("voltage_regulator", true)],
        ["refrigerator_id", build_generic_callback("refrigerator_id", true)],
        ["date_serviced", build_generic_callback("date_serviced", function(i) { return i.split("T")[0]; })]
    ];

    // END CONFIG
    if (main_col.length == 0) {
        main_col = display_cols[table_id];
    }
    // Don't call update until we have our table id and our row id
    getWhichColumnAndThen(update);
    odkCommon.registerListener(function doaction_listener() {
        var a = odkCommon.viewFirstQueuedAction();
        if (a != null) {
            // may have edited this row
            clear_cached_d_and_update();
            odkCommon.removeFirstQueuedAction();
        }
    });
}
// If we couldn't figure out our row/table ids, this function will try and get them from the view data
var getWhichColumnAndThen = function getWhichColumnAndThen(callback) {
    odkData.getViewData(function (d) {
        row_id = d.getData(0, "_id");
        table_id = d.getTableId();
        callback();
    }, failure_callback, 1, 0);
}
// Called when the user clicks the delete row button, asks for a confirmation then calls deleteRow
var _delete = function _delete() {
    if (confirm("Please confirm deletion of row " + row_id)) {
        odkData.deleteRow(table_id, null, row_id, function(d) {
            odkCommon.closeWindow();
        }, function(e) {
            alert("Failed to _delete row - " + JSON.stringify(e));
        });
    }
}
// Called with the results of our arbitraryQuery, sets cached_d and displays all the columns on the page
var update_callback = function update_callback(d) {
    cached_d = d;
    // Used for localization of column ids
    var metadata = d.getMetadata();

    // Enable the edit and delete buttons now that we know which row id we're operating on
    document.getElementById("edit").disabled = false;
    document.getElementById("delete").disabled = false;

    var ul = document.getElementById("rest");
    // Clear the "Loading..." message
    ul.innerHTML = "";
    // Handle no row
    if (d.getCount() == 0) {
        ul.innerText = "Row not found!";
    }
    // pending_media aggregates contentType and uriFragment rows until we have enough information to display them
    // Right now it depends on the fact that the rows are usually close together in the database
    var pending_media = {}
    for (var i = 0; i < d.getColumns().length; i++) {
        // col is the column key, val is the value of that cell in our row
        var col = d.getColumns()[i];
        var val = d.getData(0, col);
        // holds whether we found this column id in the colmap
        var found = false;
        // in the database, you just write the data type "picture" and the column name "some_name", and odk expands
        // that into two different columns, some_name_uriFragment and some_name_contentType
        // xlscol will hold "some_name" in the example above
        var xlscol = col;
        // If we found a uriFragment or contentType we should check to see if we have both of them yet, this variable notes that
        var checkMedia = false;
        var split = xlscol.split("_")
        // If we have a uriFragment or contentType, store the value and set the checkMedia flag
        if (["contentType", "uriFragment"].indexOf(split[split.length - 1]) >= 0) {
            var tail_fragment = split[split.length - 1];
            xlscol = split.reverse().slice(1).reverse().join("_")
            pending_media[tail_fragment] = val;
            checkMedia = true;
        }
        // Try and find it in the colmap
        for (var j = 0; j < colmap.length; j++) {
            if (colmap[j][0] == xlscol) {
                found = colmap[j];
                break;
            }
        }
        // If it's the main column (to be displayed in ibg letters at the top), put it in the header instead
        var li = null;
        if (col == main_col) {
            li = document.getElementById("main-col")
        } else {
            li = document.createElement("li");
        }
        // This has to do with how colmap is specified. If the user writes literal text, we should display that text
        // and we know we can set innerText (because setting innerHTML is slower).
        // However if we're displaying the result of a user-given callback, it might contain html, so we'll put "html" in this variable
        // If it's media, like a picture or video, it'll be a dom element, so this will be set to "element"
        var is_html = "text";
        if (checkMedia) {
            if ("contentType" in pending_media && "uriFragment" in pending_media) {
                is_html = "element";
                var type = pending_media["contentType"].split("/")[0];
                var src = odkCommon.getRowFileAsUrl(table_id, row_id, pending_media["uriFragment"]);
                if (type == "audio" || type == "video") {
                    var elem = document.createElement(type);
                    var source = document.createElement("source");
                    source.src = src;
                    elem.appendChild(source)
                    val = elem;
                } else if (type == "image") {
                    var elem = document.createElement("img");
                    elem.src = src;
                    val = elem;
                } else {
                    alert("unknown content type for column " + xlscol);
                }
                pending_media = {}
            } else {
                continue;
            }
        } 
        if (found) {
            if (typeof(found[1]) == "string") {
                li.appendChild(make_li(xlscol, found[1], val, "text"));
            } else if (found[1] === true) {
                li.appendChild(make_li(xlscol, displayCol(col, metadata), pretty(val), "text"));
            } else if (found[1] === false) {
                li.appendChild(make_li(xlscol, displayCol(col, metadata), val, "text"));
            } else {
                li.appendChild(make_li(xlscol, "", found[1](li, val, d), "html"));
            }
        } else {
            if (col[0] == "_" || colmap.length > 0) {
                // TODO check if its _sync_state or _savepoint_type and change body appropriately
                // Wasn't in the colmap and we have a colmap? Don't display it
                // If we don't have a colmap, default to displaying everything (except underscore prefixed/special columns)
                continue;
            }
            li.appendChild(make_li(xlscol, displayCol(col, metadata), val, is_html));
        }
        if (col != main_col) {
            ul.appendChild(li);
        }
    }
}
var make_li = function make_li(column_id, column_text, value_text, is_html) {
    var wrapper = document.createElement("span");
    wrapper.setAttribute("data-column", column_id);
    wrapper.classList.add("li-inner")
    var colelem = document.createElement("span");
    colelem.innerText = column_text
    colelem.style.fontWeight = "bold";
    wrapper.appendChild(colelem);
    if (is_html == "html") {
        var inner = document.createElement("span")
        inner.innerHTML = value_text;
        wrapper.appendChild(inner);
    } else if (is_html == "text") {
        wrapper.appendChild(document.createTextNode(": " + value_text));
    } else if (is_html == "element") {
        wrapper.appendChild(value_text);
    }
    return wrapper;
}
var failure_callback = function failure_callback(e) {
    alert("Error querying data: " + e);
    odkCommon.closeWindow();
}
var update = function update() {
    if (cached_d != null) {
        update_callback(cached_d);
        return;
    }
    odkData.arbitraryQuery(table_id, "SELECT " + global_which_cols_to_select + " FROM " + table_id + (global_join.trim().length > 0 ? " JOIN " : "") + global_join + " WHERE " + table_id + "._id = ?", [row_id], 1, 0, update_callback, failure_callback);
}
var clear_cached_d_and_update = function clear_cached_d_and_update() {
    cached_d = null;
    update();
}
var edit = function() {
    if (allowed_tables.indexOf(table_id) >= 0){ 
        odkTables.launchHTML({}, "config/assets/formgen/" + table_id + "#" + row_id);
    } else {
        odkTables.editRowWithSurvey({}, table_id, row_id, table_id, null, null);
    }
}



        </script>
    </head>
    <body onLoad='ol();'>
        <div id="header">
            <button id="back" onClick='odkCommon.closeWindow();'>Back</button>
            <button id="delete" onClick='_delete();' disabled>Delete Row</button>
            <button id="edit" onClick='edit();' disabled>Edit Row</button>
            <span id="main-col"></span>
        </div>
        <ul id="rest">Loading...</ul>

    <div class="main-col-wrapper">
        <div id="inject-refrigerator_id">Loading...</div>
    </div>
    <div class='h4-wrapper'><h4>Basic Refrigerator Information<h4></div>
    <ul>
        <li id='inject-facility_name'></li>
        <li id='inject-year'></li>
        <li id='inject-working_status'></li>
        <li id='inject-reason_not_working'></li>
        <li id='inject-model_id'></li>
        <li id='inject-tracking_id'></li>
        <li id='inject-voltage_regulator'></li>
        <li id='inject-date_serviced'></li>
    </ul>
    <button disabled id='open_model'>Model Information</button>
    <br />
    <button disabled id='open_hf'>Health Facility Information</button>
    <br />
    <button disabled id='add_m_log'>Add Maintenance Record</button>
    <br />
    <button disabled id='view_m_log'>View all maintenance logs</button>
    <br />
        
    </body>
</html>