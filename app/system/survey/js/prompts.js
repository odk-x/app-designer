/**
 * All  the standard prompts available to a form designer.
 */
define(['database','opendatakit','controller','backbone','moment','formulaFunctions','handlebars','promptTypes','jquery','underscore','d3','handlebarsHelpers','combodate'],
function(database,  opendatakit,  controller,  Backbone,  moment,  formulaFunctions,  Handlebars,  promptTypes,  $,       _,           d3,   _hh) {
'use strict';
/* global odkCommon, odkSurvey */
verifyLoad('prompts',
    ['database','opendatakit','controller','backbone','moment', 'formulaFunctions','handlebars','promptTypes','jquery','underscore','d3', 'handlebarsHelpers','combodate'],
    [ database,  opendatakit,  controller,  Backbone,  moment,   formulaFunctions,  Handlebars,  promptTypes,  $,       _,           d3,   _hh,           $.fn.combodate] );

promptTypes.base = Backbone.View.extend({
    className: "odk-base",
    // type should match the 'xxxx' of the promptTypes.xxxx assignment
    type: "base",
    database: database,
    controller: controller,
    // user-defined inputAttributes overrides _baseInputAttributes
    _baseInputAttributes: {},
    // the handlebars template to render
    template: null,
    //renderContext is a dynamic object to be passed into the render function.
    renderContext: {},
	display: {},

	_baseProtoDisplay: {
		constraint_message: 'constraint_message',
		invalid_value_message: 'invalid_value_message',
		required_message: 'required_message',
		required_exception_message: 'required_exception_message',
		constraint_exception_message: 'constraint_exception_message',
	},
	/**
	 * Invoked by builder() to merge the _protoDisplay fields into the display
	 * object generated by XLSXConverter. This adds in default values for the
	 * display button labels, etc. if the user has not overwritten them.
	 */
	_foldInProtoDisplayFields: function() {
		var that = this;
		var displayField = that.display;
		// build the resolved protoDisplay of this base object and the leaf.
		// Ideally, we would fold all _protoDisplay definitions up
		// the class hierarchy. Too little time to figure that out.
		var myProtoDisplay;
		if ( '_protoDisplay' in that ) {
			myProtoDisplay = _.extend({}, that._baseProtoDisplay, that._protoDisplay);
		} else {
			myProtoDisplay = _.extend({}, that._baseProtoDisplay);
		}
		// and apply the myProtoDisplay entries into the display.
		for (var property in myProtoDisplay) {
			if (myProtoDisplay.hasOwnProperty(property)) {
				if ( !(property in displayField ) ) {
					displayField[property] = myProtoDisplay[property];
				}
			}
		}
	},

    /**
     * User-overridable data and methods. These can be overridden in
     * the Excel worksheet.
     */
    // the path to the handlebars template that is compiled and stored in 'template'
    templatePath: null,
    // inputAttributes are a user-specified object that overrides _baseInputAttributes.
    inputAttributes: {},


    reRender: function(ctxt) {
        this._screen.reRender(ctxt);
    },
    /**
     * Generic methods -- probably should not be overridden
     */

    /**
     * initialize
     * called via Backbone when a new instance of this
     * prototype is constructed.
     */
    initialize: function(args) {
        $.extend(this, args);
    },
    /**
     * getPromptPath
     * retrieve the path to this prompt. This is used ONLY in
     * constructing the dispatchStruct for the
     * odkCommon.doAction(...) method and the corresponding
     * controller.actionCallback(...) method to ensure that
     * the results of an intent execution (doAction) are routed
     * back to the prompt that initiated that action.
     */
    getPromptPath: function() {
        return this._section_name + '/' + this.promptIdx;
    },
    getPromptId: function() {
        return 'i' + this.getPromptPath().replace(/[^a-zA-Z0-9]/,'');
    },
    // Add function for all prompts to use for selective reRender
	getContainerId: function() {
        var contId = "#container" + this.getPromptId();
        return contId;
    },
    /**
     * buildRenderContext
     * Called before a prompt is rendered.
     */
    buildRenderContext: function(ctxt) {
        var that = this;
        that._initializeRenderContext();

        that._whenTemplateIsReady($.extend({}, ctxt, {success: function() {
            that.configureRenderContext(ctxt);
        }}));
    },
    /**
     * _whenTemplateIsReady
     * Ensure that the template is loaded and compiled before
     * proceeding (via ctxt.success()).
     *
     * Part of the preliminaries to rendering a page.
     */
    _whenTemplateIsReady: function(ctxt){
        var that = this;
        if(that.template) {
            ctxt.success();
        } else if(that.templatePath) {
            try {
                require(['text!'+that.templatePath], function(source) {
                    try {
                        that.template = Handlebars.compile(source);
                        ctxt.log('D',"prompts."+that.type+"._whenTemplateIsReady.success",
                            " px: " + that.promptIdx);
                        // ensure that require is unwound
                        setTimeout(function() {
                                ctxt.log('I',"prompts."+that.type+"._whenTemplateIsReady.success.setTimeout",
                                            " px: " + that.promptIdx);
                                ctxt.success();
                            },
                            0 );
                    } catch (e) {
                        ctxt.log('E',"prompts."+that.type+"._whenTemplateIsReady.exception",
                            " px: " + that.promptIdx + " exception: " + e.message + " e: " + String(e));
                        ctxt.failure({message: "Error compiling handlebars template."});
                    }
                }, function(err) {
                    ctxt.log('E',"prompts."+that.type+"._whenTemplateIsReady.require.failure " + err.requireType + ' modules: ',
                        err.requireModules.toString() + " px: " + that.promptIdx);
                    ctxt.failure({message: "Error loading handlebars template."});
                });
            } catch (e) {
                ctxt.log('E',"prompts."+that.type+"._whenTemplateIsReady.require.exception",
                    " px: " + that.promptIdx + " exception: " + e.message + " e: " + String(e));
                ctxt.failure({message: "Error reading handlebars template."});
            }
        } else {
            ctxt.log('E',"prompts." + that.type + "._whenTemplateIsReady.noTemplate", "px: " + that.promptIdx);
            ctxt.failure({message: "Configuration error: No handlebars template found!"});
        }
    },
    /**
     * _initializeRenderContext
     * construct the renderContext for this prompt. This is an entirely new
     * object every time the screen is redrawn.
     */
    _initializeRenderContext: function() {
        //Object.create is used because we don't want to modify the class's render context.
        this.renderContext = Object.create(this.renderContext);
		// every prompt gets the current instance's data fields and instanceMetadata fields
		// if there is no current instanceId, then the non-session-variable fields will be null.
		var model = opendatakit.getCurrentModel();
		this.renderContext.instanceId = model.instanceId;
		this.renderContext.data = model.data;
        this.renderContext.instanceMetadata = model.instanceMetadata;
		this.renderContext.metadata = model.metadata;

        this.renderContext.calculates = formulaFunctions.calculates;
        this.renderContext.display = this.display;
        this.renderContext.promptId = this.getPromptId();
        this.renderContext.name = this.name;
        this.renderContext.disabled = this.disabled;
        this.renderContext.required = this.required;
        this.renderContext.appearance = this.appearance;
        this.renderContext.withOther = this.withOther;
        //It's probably not good to get data like this in initialize
        //Maybe it would be better to use handlebars helpers to get metadata?
        this.renderContext.form_title = opendatakit.getCurrentSectionTitle(this._section_name);
        this.renderContext.form_version = opendatakit.getSettingValue('form_version');
        // set whether we are pre-4.x Android OS (legacy compatibility)
        var platinfo = opendatakit.getPlatformInfo();
        if ( platinfo.container !== 'Android' ) {
            this.renderContext.pre4Android = false;
        } else {
            this.renderContext.pre4Android = ( platinfo.version.substring(0,1) < "4" );
        }
        this.renderContext.inputAttributes = $.extend({}, this._baseInputAttributes, this.inputAttributes);
    },
    /**
     * configureRenderContext
     * User-overridable action to perform additional actions prior to the call to render.
     */
    configureRenderContext: function(ctxt){
        ctxt.success();
    },
    /**
     * stopPropagation is used in the events map to disable swiping on various elements
     **/
    stopPropagation: function(evt){
        var that = this;
        odkCommon.log('D',"prompts." + that.type + ".stopPropagation px: " + that.promptIdx + " evt: " + evt);
        evt.stopImmediatePropagation();
    },
    afterRender: function() {},
    _render: function() {
        var that = this;
        try {
            // First check that it needs to be reRendered
            var currEl = that.$el;
            // Get the innerHTML if we can
            var currElString = null;
            var currElStringNoSpaces = null;
            if (currEl.length > 0) {
                currElString = currEl[0].innerHTML;
                currElStringNoSpaces = currElString.replace(/\s/g, '');
            }
            var toBeDrawnEl = that.template(that.renderContext);
            var tbdString = null;
            if (toBeDrawnEl !== null && toBeDrawnEl !== undefined) {
                tbdString = toBeDrawnEl.replace(/\s/g, '');
            }

            if (currElStringNoSpaces !== tbdString) {
                that.$el.html(toBeDrawnEl);
            }
        } catch(e) {
            console.error("prompts." + that.type + "._render.exception: " + String(e) + ' px: ' + that.promptIdx);
            console.error(that);
            alert("Error in template.");
        }
        return;
    },
    /**
     * _isValid isn't meant to be overidden.
     * It does validation that will be common to most prompts.
     **/
    _isValid: function(isStrict) {
        var that = this;
        var isRequired = false;

        // compute the locale and field display name...
		// used when presenting error messages.
        var locale = formulaFunctions.getCurrentLocale();

        var fieldDisplayName;
        if (that.renderContext.display) {
            var textOrMap = (that.renderContext.display.title ?
                that.renderContext.display.title : that.renderContext.display.prompt);
			textOrMap = odkCommon.lookupToken(textOrMap);
            fieldDisplayName = formulaFunctions.localize(locale, textOrMap);
        } else {
            fieldDisplayName = '';
        }

        try {
            isRequired = that.required ? that.required() : false;
        } catch (e) {
            if ( isStrict ) {
                var localizeRequiredExceptionMessage = formulaFunctions.localize(locale, that.display.required_exception_message);
                odkCommon.log('E',"prompts."+that.type+"._isValid.required.exception.strict px: " +
                    that.promptIdx + " exception: " + e.message + " e: " + String(e));
                return { message: localizeRequiredExceptionMessage + " " + fieldDisplayName };
            } else {
                odkCommon.log("W","prompts."+that.type+"._isValid.required.exception.ignored px: " +
                    that.promptIdx + " exception: " + e.message + " e: " + String(e));
                isRequired = false;
            }
        }
        that.valid = true;
        if ( !('name' in that) ) {
            // no data validation if no persistence...
            return null;
        }

        var value = that.getValue();
        if ( value === undefined || value === null || value === "" ) {
            if ( isRequired ) {
                that.valid = false;
                var localizeRequiredMessage = formulaFunctions.localize(locale, that.display.required_message);
                return { message: localizeRequiredMessage + " " + fieldDisplayName };
            }
        } else if ( 'validateValue' in that ) {
            if ( !that.validateValue() ) {
                that.valid = false;
                var localizeInvalidValueMessage = formulaFunctions.localize(locale, that.display.invalid_value_message);
                return { message: localizeInvalidValueMessage + " " + fieldDisplayName };
            }
        }
        if ( 'constraint' in that ) {
            var outcome = false;
            try {
                outcome = that.constraint({"allowExceptions":true});
                if ( !outcome ) {
                    that.valid = false;
                    var localizeConstraintMessage = formulaFunctions.localize(locale, that.display.constraint_message);
                    return { message: localizeConstraintMessage + " " + fieldDisplayName };
                }
            } catch (e) {
                var localizeConstraintExceptionMessage = formulaFunctions.localize(locale, that.display.constraint_exception_message);
                odkCommon.log('E',"prompts."+that.type+".baseValidate.constraint.exception px: " +
                    that.promptIdx + " exception: " + e.message + " e: " + String(e));
                outcome = false;
                that.valid = false;
                return { message: localizeConstraintExceptionMessage + " " + fieldDisplayName };
            }
        }
        return null;
    },
    formattedValueForContentsDisplay: function() {
        if ( !this.name ) {
            return '';
        } else {
            return this.getValue();
        }
    },
    getValue: function() {
        if (!this.name) {
            console.error("prompts."+this.type+
                ".getValue: Cannot get value of prompt with no name. px: " + this.promptIdx);
            throw new Error("Cannot get value of prompt with no name.");
        }
        return database.getDataValue(this.name);
    },
    setValueDeferredChange: function(value) {
        // NOTE: data IS NOT updated synchronously. Use callback!
        var that = this;
        database.setValueDeferredChange(that.name, value);
    },
    beforeMove: function() {
        odkCommon.log('D',"prompts." + this.type + " px: " + this.promptIdx);
        return null;
    },
    getCallback: function(promptPath) {
        throw new Error("prompts." + this.type, "px: " + this.promptIdx + " getCallback(promptPath) is unimplemented promptPath: " + promptPath );
    },
    /**
     * Useful routines to convert a selection string and an order by string
     * into a proper database query string. These strings are cached after
     * the conversion.  Used by the instances and linked_type prompts
     */
    _cachedSelection: null,
    convertSelection: function(model) {
        var that = this;
        var queryDefn = opendatakit.getQueriesDefinition(that.values_list);
        if ( queryDefn.selection === null || queryDefn.selection === undefined || queryDefn.selection.length === 0 ) {
            return null;
        }
        if ( that._cachedSelection !== null && that._cachedSelection !== undefined ) {
            return that._cachedSelection;
        }
        that._cachedSelection = database.convertSelectionString(model, queryDefn.selection);
        return that._cachedSelection;
    },
    _cachedOrderBy : null,
    convertOrderBy: function(model) {
        var that = this;
        var queryDefn = opendatakit.getQueriesDefinition(that.values_list);
        if ( queryDefn.order_by === null || queryDefn.order_by === undefined || queryDefn.order_by.length === 0 ) {
            return null;
        }
        if ( that._cachedOrderBy !== null && that._cachedOrderBy !== undefined ) {
            return that._cachedOrderBy;
        }
        that._cachedOrderBy = database.convertOrderByString(model, queryDefn.order_by);
        return that._cachedOrderBy;
    },
    populateChoicesViaQueryUsingAjax : function(query, newctxt){
        var that = this;
        var queryUri = query.uri();
        if(queryUri.search('//') < 0){
            //If the uri is not a content provider or web resource,
            //assume the path  is relative to the form directory.
            queryUri = opendatakit.getCurrentFormPath() + queryUri;
        }

        var ajaxOptions = {
            "type": 'GET',
            "url": queryUri,
            "dataType": 'json',
            "data": {},
            "success": function(result){
                that.renderContext.choices = query.callback(result);
                newctxt.success("success");
            },
            "error": function(e) {
                //This is a passive error because there could just be a problem
                //with the content provider/network/remote service rather than with
                //the form.
                newctxt.log('W',"prompts." + this.type + ".configureRenderContext.error",
                            "px: " + this.promptIdx + " Error fetching choices " + e);
                that.renderContext.passiveError = "Error fetching choices.\n";
                if(e.statusText) {
                    that.renderContext.passiveError += e.statusText;
                }
                // TODO: verify how this error should be handled...
                newctxt.failure({message: "Error fetching choices via ajax."});
            }
        };

        //TODO: It might also be desireable to make it so queries can reference
        //datasheets in the XLSX file.
        var queryUriExt = queryUri.split('.').pop();
        if(queryUriExt === 'csv') {
            ajaxOptions.dataType = 'text';
            ajaxOptions.success = function(result) {
                try {
                    //require(['jquery-csv'], function(){
                        that.renderContext.choices = query.callback($.csv.toObjects(result));
                        newctxt.success("success");
                    //},
                    //function (err) {
                    //    newctxt.log('E',"prompts."+that.type+".require.failure " + err.requireType + ' modules: ',
                    //        err.requireModules.toString() + " px: " + that.promptIdx);
                    //    newctxt.failure({message: "Error fetching choices from csv data."});
                    //});
                } catch (e) {
                    newctxt.log('E',"promptType." + that.type, "exception: " + e.message + " e: " + e.toString());
                    newctxt.failure({message: "Error reading choices from csv data."});
                }
            };
        }
        $.ajax(ajaxOptions);
    },
    __test__: function(evt){
        //This is a utility function for checking to make sure event maps are working.
        odkCommon.log('T',evt);
    }
});
promptTypes.opening = promptTypes.base.extend({
    type: "opening",
    hideInContents: true,
    templatePath: "templates/opening.handlebars",
	_protoDisplay: {
		opening_survey_form_identification: 'survey_form_identification',
		opening_survey_instance_detail: 'opening_survey_instance_detail',
		opening_survey_next_button_label: 'opening_survey_next_button_label' },
    configureRenderContext: function(ctxt) {
        var that = this;
        var formLogo = false;//TODO: Need way to access form settings.
        if(formLogo){
            this.renderContext.headerImg = formLogo;
        }
        var lastSave = database.getInstanceMetaDataValue('_savepoint_timestamp');
        var ts = that.renderContext.last_save_date = odkCommon.toDateFromOdkTimeStamp(lastSave);

        var displayElementName = opendatakit.getSettingValue('instance_name');
        if ( displayElementName !== null && displayElementName !== undefined ) {
            that.renderContext.display_field = database.getDataValue(displayElementName);
        } else if ( ts === null ) {
			that.renderContext.display_field = null;
		} else {
            // Now we are always going to display instance id
            // unless this decision changes ...
            that.renderContext.display_field = ts.toISOString();
        }
        if ( that._screen && that._screen._renderContext ) {
            that._screen._renderContext.enableBackNavigation = false;
        }
        ctxt.success();
    },
    renderContext: {
        headerImg: requirejs.toUrl('../config/assets/img/form_logo.png'),
        backupImg: requirejs.toUrl('../config/assets/img/backup.png'),
        advanceImg: requirejs.toUrl('../config/assets/img/advance.png')
    },
    //Events copied from input_type, should probably refactor.
    events: {
        "swipeleft .input-container": "stopPropagation",
        "swiperight .input-container": "stopPropagation"
    }
});
promptTypes.finalize = promptTypes.base.extend({
    type:"finalize",
    hideInContents: true,
    valid: true,
    templatePath: "templates/finalize.handlebars",
	_protoDisplay: {
		finalize_survey_form_identification: 'survey_form_identification',
		finalize_survey_instance_detail: 'finalize_survey_instance_detail',
		finalize_survey_button_label: 'finalize_survey_button_label',
		save_as_incomplete_survey_button_label: 'save_as_incomplete_survey_button_label' },
    events: {
        "click .incomplete": "saveIncomplete",
        "click .finalize": "saveFinal"
    },
    renderContext: {
        headerImg: requirejs.toUrl('../config/assets/img/form_logo.png')
    },
    configureRenderContext: function(ctxt) {
        var that = this;
        var formLogo = false;//TODO: Need way to access form settings.
        if(formLogo){
            this.renderContext.headerImg = formLogo;
        }
        var lastSave = database.getInstanceMetaDataValue('_savepoint_timestamp');
        var ts = odkCommon.toDateFromOdkTimeStamp(lastSave);

        var displayElementName = opendatakit.getSettingValue('instance_name');
        if ( displayElementName !== null && displayElementName !== undefined ) {
            that.renderContext.display_field = database.getDataValue(displayElementName);
        } else {
            // Now we are always going to display instance id
            // unless this decision changes ...
            that.renderContext.display_field = ts.toISOString();
        }
        if ( that._screen && that._screen._renderContext ) {
            that._screen._renderContext.enableForwardNavigation = false;
        }
        ctxt.success();
    },
    saveIncomplete: function(evt) {
        var that = this;
        evt.stopPropagation();
        evt.stopImmediatePropagation();

        var ctxt = that.controller.newContext(evt, that.type + ".saveIncomplete");
        that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
            ctxt.log('D',"prompts." + that.type + ".saveIncomplete", "px: " + that.promptIdx);
            that.controller.saveIncomplete($.extend({},ctxt,{success:function() {
                    that.controller.leaveInstance(ctxt);
                }}));
        }, failure: function(m) {
            ctxt.log('D',"prompts." + that.type + ".saveIncomplete -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
            ctxt.failure(m);
        }}));
    },
    saveFinal: function(evt) {
        var that = this;
        evt.stopPropagation();
        evt.stopImmediatePropagation();

        var ctxt = that.controller.newContext(evt, that.type + ".saveFinal");
        that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
            ctxt.log('D',"prompts." + that.type + ".saveFinal", "px: " + that.promptIdx);
            that.controller.gotoFinalizeAndTerminateAction(ctxt);
        }, failure: function(m) {
            ctxt.log('D',"prompts." + that.type + ".saveFinal -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
            ctxt.failure(m);
        }}));
    }
});
promptTypes.json = promptTypes.base.extend({
    type:"json",
    hideInContents: true,
    valid: true,
    templatePath: "templates/json.handlebars",
    configureRenderContext: function(ctxt) {
        var that = this;
        if ( JSON !== null && JSON !== undefined ) {
            that.renderContext.value = JSON.stringify(database.getAllDataValues(),null,2);
        } else {
            that.renderContext.value = "JSON Unavailable";
        }
        if ( that._screen && that._screen._renderContext ) {
            that._screen._renderContext.enableNavigation = false;
        }
        ctxt.success();
    }
});
promptTypes.instances = promptTypes.base.extend({
    type:"instances",
    hideInContents: true,
    valid: true,
    _cachedEvent: null,
	_protoDisplay: {
		instances_survey_form_identification: 'survey_form_identification',
		new_button_label: 'instances_survey_create_button_label',
		instances_last_save_date_label: 'instances_last_save_date_label',
		instances_no_saved_instances_label: 'instances_no_saved_instances_label' },
    savepoint_type_finalized_text: 'savepoint_type_finalized_text_label',
    savepoint_type_incomplete_text: 'savepoint_type_incomplete_text_label',
    savepoint_type_checkpoint_text: 'savepoint_type_checkpoint_text_label',
    templatePath: "templates/instances.handlebars",
    events: {
        "click .openInstance": "openInstance",
        "click .deleteInstance": "confirmDeleteInstance",
        "click .createInstance": "createInstance"
    },
    configureRenderContext: function(ctxt) {
        var that = this;
        ctxt.log('D',"prompts." + that.type + ".configureRenderContext", "px: " + that.promptIdx);

        // see if we are supposed to apply a query filter to this...
        var model = opendatakit.getCurrentModel();
        var displayElementName = opendatakit.getSettingValue('instance_name');
        var selection = null;
        var selectionArgs = null;
        var orderBy = null;
        if ( that.values_list !== undefined && that.values_list !== null ) {
            var queryDefn = null;
            queryDefn = opendatakit.getQueriesDefinition(that.values_list);
            if ( queryDefn === undefined || queryDefn === null ) {
                ctxt.failure({message: "Error displaying instances: could not retrieve query definition"});
                return;
            } else
            if ( queryDefn.linked_table_id !== opendatakit.getCurrentTableId() ) {
                ctxt.failure({message: "Error displaying instances: tableId of value_list query does not match current tableId"});
                return;
            }
            selection = that.convertSelection(model);
            selectionArgs = queryDefn.selectionArgs();
            orderBy = that.convertOrderBy(model);
        }

        // in this case, we are our own 'linked' table.
        database.get_linked_instances($.extend({},ctxt,{success:function(instanceList) {
                that.renderContext.instances = _.map(instanceList, function(term) {
                    var savepoint_type = term.savepoint_type;
                    if ( savepoint_type === opendatakit.savepoint_type_complete ) {
                        term.savepoint_type_text = that.savepoint_type_finalized_text;
						term.is_checkpoint = false;
                    } else if ( savepoint_type === opendatakit.savepoint_type_incomplete ) {
                        term.savepoint_type_text = that.savepoint_type_incomplete_text;
						term.is_checkpoint = false;
                    } else {
                        term.savepoint_type_text = that.savepoint_type_checkpoint_text;
						term.is_checkpoint = true;
                    }
					// this field is undefined if rendering through the app designer
					var effective_access = term.effective_access;
					if ( effective_access === undefined || effective_access === null || effective_access.indexOf("rwd") !== -1 ) {
						term.show_delete = true;
					} else {
						term.show_delete = false;
					}
                    return term;
                });

                $.extend(that.renderContext, {
                    headerImg: requirejs.toUrl('../config/assets/img/form_logo.png')
                });
                if ( that._screen && that._screen._renderContext ) {
                    that._screen._renderContext.showHeader = false;
                    that._screen._renderContext.enableNavigation = false;
                    that._screen._renderContext.showFooter = false;
                }
                ctxt.success();
            }
        }), model.table_id, selection, selectionArgs, displayElementName, orderBy);
    },
    createInstance: function(evt){
        var that = this;
        evt.stopPropagation(true);
        evt.stopImmediatePropagation();

        var ctxt = that.controller.newContext(evt, that.type + ".createInstance");
        that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
            ctxt.log('D',"prompts." + that.type + ".createInstance", "px: " + that.promptIdx);
            that.controller.createInstance(ctxt);
        }, failure: function(m) {
            ctxt.log('D',"prompts." + that.type + ".createInstance -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
            ctxt.failure(m);
        }}));
    },
    openInstance: function(evt) {
        var that = this;
        evt.stopPropagation(true);
        evt.stopImmediatePropagation();
        var instanceIdToOpen = $(evt.currentTarget).attr('id');

        if ( instanceIdToOpen !== null && instanceIdToOpen !== undefined ) {
            var ctxt = that.controller.newContext(evt, that.type + ".openInstance");
            that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
                ctxt.log('D',"prompts." + that.type + ".openInstance", "px: " + that.promptIdx);
                that.controller.openInstance(ctxt, instanceIdToOpen);
            }, failure: function(m) {
                ctxt.log('D',"prompts." + that.type + ".createInstance -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
                ctxt.failure(m);
            }}));
        }
    },
    confirmDeleteInstance: function(evt) {
        var that  = this;
        that._cachedEvent = evt;
        var instanceDisplayValueToDelete = $(evt.currentTarget).attr('display_value');
        that._screen._screenManager.showConfirmationPopup({message: {text: "Delete " + instanceDisplayValueToDelete + " ?"},
                                                           promptIndex: that.promptIdx});
    },
    handleConfirmation: function(){
        var that = this;

        if (that._cachedEvent === null || that._cachedEvent === undefined) {
            return;
        }

        var instanceIdToDelete = $(that._cachedEvent.currentTarget).attr('id');

        if ( instanceIdToDelete !== null && instanceIdToDelete !== undefined ) {
            var ctxt = that.controller.newContext(that._cachedEvent, that.type + ".deleteInstance");
            that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
                ctxt.log('D',"prompts." + that.type + ".deleteInstance", "px: " + that.promptIdx);
                var model = opendatakit.getCurrentModel();
                // in this case, we are our own 'linked' table.
                database.delete_checkpoints_and_row($.extend({}, ctxt, {success: function() {
                        that.reRender(ctxt);
                    }}),
                model, instanceIdToDelete);
            }, failure: function(m) {
                ctxt.log('D',"prompts." + that.type + ".deleteInstance -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
                ctxt.failure(m);
            }}));
        }
    }
});
promptTypes.contents = promptTypes.base.extend({
    type:"contents",
    hideInContents: true,
    valid: true,
    templatePath: 'templates/contents.handlebars',
    events: {
        "click .select-contents-item": "selectContentsItem"
    },
    selectContentsItem: function(evt) {
        var that = this;
        var selectedScreenPath = null;
        odkCommon.log('D',"prompts." + that.type + ".selectContentsItem: click detected: " + evt.target);
        var $target = $(evt.target).closest('.select-contents-item');
        $target.attr("label", function(index, oldPropertyValue){
            odkCommon.log('D',"prompts." + that.type + ".selectContentsItem: click near label: " + oldPropertyValue +
                "px: " + that.promptIdx);
            selectedScreenPath = oldPropertyValue;
        });

        if ( selectedScreenPath !== null ) {
            var ctxt = that.controller.newContext(evt, that.type + ".selectContentsItem");
            that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
                ctxt.log('D',"prompts." + that.type + ".selectContentsItem: gotoScreenPath: " + selectedScreenPath,
                    "px: " + that.promptIdx);
                // TODO: allow user to specify whether or not this is an 'advancing' operation
                that.controller.gotoScreenPath(ctxt, selectedScreenPath, true);
            }, failure: function(m) {
                ctxt.log('D',"prompts." + that.type + ".selectContentsItem -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
                ctxt.failure(m);
            }}));
        }
    },
    configureRenderContext: function(ctxt) {
        var that = this;
        that.renderContext.prompts = that.controller.getCurrentSectionPrompts();
        if ( that._screen && that._screen._renderContext ) {
            that._screen._renderContext.showHeader = true;
            that._screen._renderContext.showFooter = false;
        }
        ctxt.success();
    }
});
promptTypes._linked_type = promptTypes.base.extend({
    type: "_linked_type",
    getLinkedTableId: function() {
        var queryDefn = opendatakit.getQueriesDefinition(this.values_list);
        if ( queryDefn !== null && queryDefn !== undefined )
        {
            if ( queryDefn.linked_table_id === null || queryDefn.linked_table_id === undefined ) {
                return queryDefn.linked_form_id;
            } else {
                return queryDefn.linked_table_id;
            }
        } else {
            odkCommon.log('E',"query definiton is null for " + this.type + " in getLinkedTableId");
            return null;
        }
    },
    getLinkedFormId: function() {
        var queryDefn = opendatakit.getQueriesDefinition(this.values_list);
        if ( queryDefn !== null && queryDefn !== undefined )
        {
            return queryDefn.linked_form_id;
        } else {
            odkCommon.log('E',"query definiton is null for " + this.type + " in getLinkedFormId");
            return null;
        }
    },
    _linkedCachedModel: null,
    _linkedCachedInstanceName: null,
    getLinkedInstanceName: function() {
        return this._linkedCachedInstanceName;
    },
    getlinkedModel: function(ctxt) {
        var that = this;
        if ( that._linkedCachedModel !== null && that._linkedCachedModel !== undefined ) {
            ctxt.success(that._linkedCachedModel);
            return;
        }
        var filePath = odkSurvey.getFormPath(that.getLinkedTableId(), that.getLinkedFormId()) + 'formDef.json';
        opendatakit.readFormDefFile($.extend({},ctxt,{success:function(formDef) {
             var ino = opendatakit.getSettingObject(formDef, 'instance_name');
             if ( ino !== null ) {
                that._linkedCachedInstanceName = ino.value;
            } else {
                that._linkedCachedInstanceName = null;
            }
            database.readTableDefinition($.extend({}, ctxt, {success:function(tlo) {
                ctxt.log('D',"prompts." + that.type +
                    'getlinkedModel.readTableDefinition.success', "px: " + that.promptIdx );
                that._linkedCachedModel = tlo;
                ctxt.success(tlo);
            }}), formDef, that.getLinkedTableId(), filePath);
        }}), filePath );
    },
    getCallback: function(promptPath) {
        var that = this;
        if ( that.getPromptPath() != promptPath ) {
            throw new Error("Promptpath does not match: " + promptPath + " vs. " + that.getPromptPath());
        }
        return function(ctxt, internalPromptContext, action, jsonObject) {
            ctxt.log('D',"prompts." + that.type + 'getCallback.actionFn', "px: " + that.promptIdx +
                " promptPath: " + promptPath + " internalPromptContext: " + internalPromptContext + " action: " + action);
            if (jsonObject.status === -1 /* Activity.RESULT_OK */ ) {
                ctxt.log('D',"prompts." + that.type + 'getCallback.actionFn.resultOK', "px: " + that.promptIdx +
                    " promptPath: " + promptPath + " internalPromptContext: " + internalPromptContext + " action: " + action);
                that.enableButtons();
                that.reRender(ctxt);
            }
            else {
                ctxt.log('W',"prompts." + that.type + 'getCallback.actionFn.failureOutcome failure returned from intent',
                    "px: " + that.promptIdx + " promptPath: " + promptPath + " internalPromptContext: " +
                    internalPromptContext + " action: " + action);
                that.enableButtons();
                that.reRender($.extend({}, ctxt, {success: function() { ctxt.failure({message: "Action canceled."});},
                    failure: function(m) { ctxt.failure({message: "Action canceled."});}}));
            }
        };
    }
});
promptTypes.linked_table = promptTypes._linked_type.extend({
    type: "linked_table",
    valid: true,
    _cachedEvent: null,
	_protoDisplay: {
		new_button_label: 'linked_table_new_instance_label',
		},
    templatePath: 'templates/linked_table.handlebars',
    launchAction: 'org.opendatakit.survey.activities.MainMenuActivity',

    events: {
        "click .openInstance": "openInstance",
        "click .deleteInstance": "confirmDeleteInstance",
        "click .addInstance": "addInstance"
    },
    disableButtons: function() {
        var that = this;
        that.$('.openInstance').prop('disabled', true);
        that.$('.deleteInstance').prop('disabled', true);
        that.$('.addInstance').prop('disabled', true);
    },
    enableButtons: function() {
        var that = this;
        that.$('.openInstance').prop('disabled', false);
        that.$('.deleteInstance').prop('disabled', false);
        that.$('.addInstance').prop('disabled', false);
    },
    choice_filter: function(){ return true; },
    configureRenderContext: function(ctxt) {
        var that = this;
        var queryDefn = opendatakit.getQueriesDefinition(this.values_list);
        ctxt.log('D',"prompts." + that.type + ".configureRenderContext", "px: " + that.promptIdx);
        that.renderContext.new_instance_text = ((that.display.new_instance_text !== null &&
                that.display.new_instance_text !== undefined) ? that.display.new_instance_text : "New");
        that.getlinkedModel($.extend({},ctxt,{success:function(linkedModel) {
            var dbTableName = linkedModel.table_id;
            var selString = that.convertSelection(linkedModel);
            var selArgs = queryDefn.selectionArgs();
            var ordBy = that.convertOrderBy(linkedModel);
            var displayElementName = that.getLinkedInstanceName();
            ctxt.log('D',"prompts." + that.type + ".configureRenderContext.before.get_linked_instances", "px: " + that.promptIdx);
            database.get_linked_instances($.extend({},ctxt,{success:function(instanceList) {
                ctxt.log('D',"prompts." + that.type + ".configureRenderContext.success.get_linked_instances", "px: " + that.promptIdx);
                var filteredInstanceList = _.filter(instanceList, function(instance) {
                    return that.choice_filter(instance);
                });
                instanceList = filteredInstanceList;
                // set the image icon
                for (var i = 0; i < instanceList.length ; i++){
                    // sets the savepoint_type to incomplete if the formId doesn't match the current form
                    if (instanceList[i].form_id != that.getLinkedFormId()) {
                        instanceList[i].savepoint_type = opendatakit.savepoint_type_incomplete;
                    }

                    if (instanceList[i].savepoint_type == "COMPLETE"){
                        instanceList[i].icon_class = "glyphicon-ok";
                    }
                    else{
                        instanceList[i].icon_class = "glyphicon-warning-sign";
                    }
                    //make the date more readable
                    instanceList[i].savepoint_timestamp = opendatakit.getShortDateFormat(instanceList[i].savepoint_timestamp);
                }

                that.renderContext.instances = instanceList;

                that.renderContext.columns = [
                    { title : "Last Saved"},
                    { title : "Name"},
                    { title : "Finalized"},
                    { title : ""}
                ];



                ctxt.log('D',"prompts." + that.type + ".configureRenderContext.success.get_linked_instances.success", "px: " + that.promptIdx + " instanceList: " + instanceList.length);
                ctxt.success();
            }}), dbTableName, selString, selArgs, displayElementName, ordBy);
        }}));
    },
    openInstance: function(evt) {
        var instanceId;
        var openButton = $(evt.target).closest(".openInstance");

        if (openButton !== null && openButton !== undefined) {
            instanceId = openButton.attr("instance-id");
        }
        else {
            odkCommon.log('E',"In linked_table.openInstance instanceId is undefined");
            return;
        }

        var that = this;
        that.disableButtons();
        var platInfo = opendatakit.getPlatformInfo();
        var queryDefn = opendatakit.getQueriesDefinition(this.values_list);

        var openInstanceElementKeyToValueMap = null;
        if ( queryDefn.openRowInitialElementKeyToValueMap ) {
            openInstanceElementKeyToValueMap = queryDefn.openRowInitialElementKeyToValueMap();
        }

        var dispatchStruct = {promptPath: that.getPromptPath(), userAction: 'launchSurvey'};

		var outcome = odkSurvey.openInstance(dispatchStruct,
			that.getLinkedTableId(),
			that.getLinkedFormId(),
			instanceId, openInstanceElementKeyToValueMap);

        odkCommon.log('D','linked_table.openInstance - doAction: ' +  platInfo.container + " outcome is " + outcome);
        if (outcome === null || outcome !== "OK") {
            odkCommon.log('W',"linked_table.openInstance - doAction cancelled -- Should be OK got >" + outcome + "<");
            that.enableButtons();
        } else {
            odkCommon.log('W',"linked_table.openInstance - doAction in play -- awaiting responseAvailable");
        }
    },
    confirmDeleteInstance: function(evt) {
        var that = this;
        var instanceId;
        var instanceName;
        var deleteButton = $(evt.target).closest(".deleteInstance");

        if (deleteButton !== null && deleteButton !== undefined) {
            instanceId  = deleteButton.attr("instance-id");
            instanceName = deleteButton.attr("instance-name");
        }
        else {
            odkCommon.log('E',"In linked_table.confirmDeleteInstance instanceId is undefined");
            return;
        }

        that._cachedEvent = evt;
        that._screen._screenManager.showConfirmationPopup({message: {text: "Delete " + instanceName + "?"},
                                                           promptIndex:that.promptIdx});
    },
    handleConfirmation: function() {
        var that = this;

        if (that._cachedEvent === null || that._cachedEvent === undefined ) {
            odkCommon.log('E',"In linked_table.handleConfirmation _cachedEvent is null");
            return ({message:"In linked_table.deleteInstance _cachedEvent is null"});
        }
        var instanceId;
        var deleteButton = $(that._cachedEvent.target).closest(".deleteInstance");

        if (deleteButton !== null && deleteButton !== undefined) {
            instanceId  = deleteButton.attr("instance-id");
        }
        else {
            odkCommon.log('W',"In linked_table.handleConfirmation instanceId is undefined");
            return null;
        }

        // TODO: should this be done here? Seems like it should wait for a reRender
        // var tableRow = $(that._cachedEvent.target).closest(".linkedTable tr");
        // if (tableRow !== null && tableRow !== undefined) {
        //     tableRow.remove();
        // }
        that.disableButtons();

        var ctxt = that.controller.newContext(that._cachedEvent, that.type + ".handleConfirmation");
        that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
            ctxt.log('D',"prompts." + that.type + ".handleConfirmation", "px: " + that.promptIdx);
            that.getlinkedModel($.extend({},ctxt,{success:function(linkedModel) {
                database.delete_checkpoints_and_row($.extend({},ctxt,{success:function() {
                        that.enableButtons();
                        that.reRender(ctxt);
                    },
                    failure:function(m) {
                        that.enableButtons();
                        that.reRender($.extend({},ctxt,{success:function() {
                                ctxt.failure(m);
                            },
                            failure:function(m2) {
                                ctxt.failure(m2);
                            }}));
                    }}), linkedModel, instanceId);
            }}));
        }, failure: function(m) {
            ctxt.log('D',"prompts." + that.type + ".handleConfirmation -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
            that.enableButtons();
            ctxt.failure(m);
        }}));
        that._cachedEvent = null;
        return null;
    },
    addInstance: function(evt) {
        var that = this;
        var queryDefn = opendatakit.getQueriesDefinition(this.values_list);
        that.disableButtons();
        var platInfo = opendatakit.getPlatformInfo();

        var newInstanceElementKeyToValueMap = null;
        if ( queryDefn.newRowInitialElementKeyToValueMap ) {
            newInstanceElementKeyToValueMap = queryDefn.newRowInitialElementKeyToValueMap();
        }

        var dispatchStruct = {promptPath: that.getPromptPath(), userAction: 'launchSurvey'};

		var outcome = odkSurvey.addInstance(dispatchStruct,
			that.getLinkedTableId(),
			that.getLinkedFormId(),
			newInstanceElementKeyToValueMap);

        odkCommon.log('D','linked_table.addInstance - doAction: ' +  platInfo.container + " outcome is " + outcome);
        if (outcome === null || outcome !== "OK") {
            odkCommon.log('W',"linked_table.addInstance - doAction cancelled -- Should be OK got >" + outcome + "<");
            that.enableButtons();
        } else {
            odkCommon.log('W',"linked_table.addInstance - doAction in play -- awaiting responseAvailable");
        }
    }
});
promptTypes.external_link = promptTypes.base.extend({
    type: "external_link",
    valid: true,
	_protoDisplay: {
		new_button_label: 'external_link_button_label' },
    templatePath: 'templates/external_link.handlebars',
    url: null,
    renderContext: {
    },
    events: {
        "click .openLink": "openLink"
    },
    disableButtons: function() {
        var that = this;
        that.$('.openLink').prop('disabled',true);
    },
    enableButtons: function() {
        var that = this;
        that.$('.openLink').prop('disabled',false);
    },
    openLink: function(evt) {
        var that = this;
        var fullUrl = that.url();
        var platInfo = opendatakit.getPlatformInfo();

        that.disableButtons();

        var dispatchStruct = {promptPath: that.getPromptPath(), userAction: 'openLink'};

		var outcome = odkSurvey.openLink(dispatchStruct, fullUrl);
        odkCommon.log('D',"prompts." + that.type + ".openLink - doAction: " +  platInfo.container + " outcome is " + outcome);
        if (outcome === null || outcome !== "OK") {
            odkCommon.log('W',"prompts." + that.type + ".openLink - doAction cancelled -- Should be OK got >" + outcome + "<");
            that.enableButtons();
        } else {
            odkCommon.log('W',"prompts." + that.type + ".openLink - doAction in play -- awaiting responseAvailable");
        }
    },
    getCallback: function(promptPath) {
        var that = this;
        if ( that.getPromptPath() != promptPath ) {
            throw new Error("Promptpath does not match: " + promptPath + " vs. " + that.getPromptPath());
        }
        return function(ctxt, internalPromptContext, action, jsonObject) {
            ctxt.log('D',"prompts." + that.type + 'getCallback.actionFn', "px: " + that.promptIdx +
                " promptPath: " + promptPath + " internalPromptContext: " + internalPromptContext + " action: " + action);
            if (jsonObject.status === -1 /* Activity.RESULT_OK */ ) {
                ctxt.log('D',"prompts." + that.type + 'getCallback.actionFn.resultOK', "px: " + that.promptIdx +
                    " promptPath: " + promptPath + " internalPromptContext: " + internalPromptContext + " action: " + action);
                that.enableButtons();
                that.reRender(ctxt);
            }
            else {
                ctxt.log('W',"prompts." + that.type + 'getCallback.actionFn.failureOutcome failure returned from intent:',
                    "px: " + that.promptIdx + " promptPath: " + promptPath + " internalPromptContext: " +
                    internalPromptContext + " action: " + action);
                that.enableButtons();
                that.reRender($.extend({}, ctxt, {success: function() { ctxt.failure({message: "Action canceled."});},
                    failure: function(j) { ctxt.failure({message: "Action canceled."});}}));
            }
        };
    }
});
promptTypes.user_branch = promptTypes.base.extend({
    type: "user_branch",
    templatePath: "templates/user_branch.handlebars",
    renderContext: {
    },
    events: {
        "click .branch-select-item": "selectBranchItem"
    },
    selectBranchItem: function(evt) {
        var that = this;
        odkCommon.log('D',"prompts." + that.type + ".selectBranchItem: click detected: " + evt.target);
        var $target = $(evt.target).closest('.branch-select-item');

        var currentPath = that.controller.getCurrentScreenPath();
        var parts = currentPath.split("/");
        if ( parts.length < 2 ) {
            odkCommon.log('E',"prompts." + that.type + ".selectBranchItem: invalid currentPath: " + currentPath);
            return;
        }

        var newPath = null;
        $target.attr("label", function(index, oldPropertyValue) {
            newPath = parts[0] + "/" + oldPropertyValue;
        });

        if ( newPath !== null && newPath !== undefined ) {
            var ctxt = that.controller.newContext(evt, that.type + ".selectBranchItem");
            that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
                ctxt.log('D',"prompts." + that.type + ".selectBranchItem: click gotoScreenPath: " + newPath);
                // TODO: allow user to specify whether or not this is an 'advancing' operation
                that.controller.gotoScreenPath(ctxt,newPath,true);
            },
            failure:function(m) {
                ctxt.log('D',"prompts." + that.type + ".selectBranchItem -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
                ctxt.failure(m);
            }}));
        }
    },
    choice_filter: function(){ return true; },
    configureRenderContext: function(ctxt) {
        var that = this;
        var newctxt = $.extend({}, ctxt, {success: function(outcome) {
            ctxt.log('D',"prompts." + that.type + ".configureRenderContext." + outcome,
                        "px: " + that.promptIdx);
            ctxt.success();
        }});

        that.renderContext.passiveError = null;
        var queryDefn = opendatakit.getQueriesDefinition(that.values_list);
        var choiceListDefn = opendatakit.getChoicesDefinition(that.values_list);
        if(queryDefn !== null && queryDefn !== undefined) {
            that.populateChoicesViaQueryUsingAjax(queryDefn, newctxt);
        } else if (choiceListDefn !== null && choiceListDefn !== undefined) {
            //Very important.
            //We need to clone the choices so their values are unique to the prompt.
            that.renderContext.choices = _.map(choiceListDefn, _.clone);
            newctxt.success("choiceList.success");
        } else {
            newctxt.failure({message: "Error fetching choices -- no ajax query or choices defined"});
        }
    }
});
promptTypes.select = promptTypes._linked_type.extend({
    type: "select",
	_protoDisplay: {
		deselect: false,
		select_deselect_label: 'select_deselect_label',
		select_one_dropdown_label: 'select_one_dropdown_label',
		select_with_other_other_label: 'select_with_other_other_label' },
    templatePath: "templates/select.handlebars",
    events: {
        "change input": "modification",
        "change select": "modification",
        //Only needed for child views
        "click .deselect": "deselect",
        "click .grid-select-item": "selectGridItem",
        "taphold .ui-radio": "deselect"
    },
    selectGridItem: function(evt) {
        var $target = $(evt.target).closest('.grid-select-item');
        var $input = $target.find('input');
        $input.prop("checked", function(index, oldPropertyValue) {
            if( oldPropertyValue ) {
                $input.prop("checked", false);
                $input.change();
            } else {
                $input.prop("checked", true);
                $input.change();
            }
        });
    },
    reRender: function(evt) {
        var that = this;
        var conIdx = that.getContainerId();
        var screenRedraw = that._screen.havePromptsOnScreenChanged(that.promptIdx);
        if (screenRedraw) {
            // Need to create a context here since
            // screen reRender requires a valid context
            var ctxt = that.controller.newContext(evt, that.type + ".reRender");
            that.controller.enqueueTriggeringContext($.extend({}, ctxt, {
                success: function() {
                    odkCommon.log('D', "prompts." + that.type + ".reRender: _screen.reRender", "px: " + that.promptIdx);
                    that._screen.reRender(ctxt);
                },
                failure: function(m) {
                    odkCommon.log('D', "prompts." + that.type + ".reRender: -- prior event terminated with an error -- aborting", "px: " + that.promptIdx);
                    ctxt.failure(m);
                }
            }));

        } else {
            that._render();
            if(!that.$el){
                console.error("render px: " + that.promptIdx +
                " Prompts must have synchronous render functions. " +
                "Don't debounce them or launch async calls before el is set.");
                console.error(that);
                alert("Sub-prompt has not been rendered. See console for details.");
            }

            var $container = that._screen.$(that.getContainerId());
            $container.html(that.$el);
        }
    },
    choice_filter: function(){ return true; },
    updateRenderValue: function(formValue) {
        var that = this;
        //that.renderContext.value = formValue;
        var filteredChoices = _.filter(that.renderContext.choices, function(choice) {
            return that.choice_filter(choice);
        });

        if ( !formValue ) {
            that.renderContext.choices = _.map(filteredChoices, function(choice) {
                choice.checked = false;
                return choice;
            });
            if(this.withOther) {
                that.renderContext.other = null;
            }
            return;
        }
        //Check appropriate choices based on formValue
        that.renderContext.choices = _.map(filteredChoices, function(choice) {
            choice.checked = _.any(formValue, function(valueObject) {
                return choice.data_value === valueObject.value;
            });
            return choice;
        });
        if(this.withOther) {
            var otherObject = _.find(formValue, function(valueObject) {
                return ('otherValue' === valueObject.name);
            });
            that.renderContext.other = {
                value: otherObject ? otherObject.value : '',
                checked: _.any(formValue, function(valueObject) {
                    return ('other' === valueObject.value);
                })
            };
        }
    },
    generateSaveValue: function(jsonFormSerialization) {
        var that = this;
        var selectedValues;
        if(jsonFormSerialization){
            selectedValues = _.map(jsonFormSerialization, function(valueObject) {
                if ( valueObject.name === that.name ) {
                    return valueObject.value;
                }
            });
            if(selectedValues && that.withOther) {
                var otherValue = _.find(selectedValues, function(value) {
                        return ('other' === value);
                    });
                if (otherValue) {
                    var otherObject = _.find(jsonFormSerialization, function(valueObject) {
                        return ('otherValue' === valueObject.name);
                        });
                    selectedValues.push(otherObject.value);
                }
            }
            if (selectedValues !== null && (selectedValues === undefined || selectedValues.length === 0)) {
              selectedValues = null;
            }
            return selectedValues;
        }
        return null;
    },
    parseSaveValue: function(savedValue) {
        //Note that this function expects to run after this.renderContext.choices
        //has been initilized.
        var that = this;
        var otherChoices = [];
        var matchedChoice = null;
        var choiceList = [];
        var newChoice = null;

        if (savedValue === null || savedValue === undefined)
            return choiceList;

        for (var i = 0; i < savedValue.length; i++)
        {
            matchedChoice = _.find(that.renderContext.choices, function(choiceObject) {
                return (savedValue[i] === choiceObject.data_value);
            });

            if ( matchedChoice !== null && matchedChoice !== undefined ) {
                newChoice = { "name": that.name, "value": savedValue[i] };
                choiceList.push(newChoice);
            } else {
                otherChoices.push(savedValue[i]);
            }
        }

        if (that.withOther && otherChoices.length === 1 ) {
            // emit the other choice list and the value for it...
            choiceList.push({
                "name": that.name,
                "value": "other"
            });
            choiceList.push({
                "name": "otherValue",
                "value": otherChoices[0]
            });
        } else if ( otherChoices.length > 0 ) {
            odkCommon.log('W',"prompts." + this.type + " px: " + this.promptIdx + " invalid choices are in choices list");
        }

        return choiceList;
    },
    modification: function(evt) {
        var that = this;
        odkCommon.log('D',"prompts." + that.type + ".modification - px: " + that.promptIdx + " val: " + $(evt.target).attr('value'));
        if(that.withOther) {
            //This hack is needed to prevent rerendering
            //causing the other input to loose focus when clicked.
            if( $(evt.target).val() === 'other' &&
                $(evt.target).prop('checked') &&
                //The next two lines determine if the checkbox was already checked.
                that.renderContext.other &&
                that.renderContext.other.checked) {
                odkCommon.log('D',"prompts." + that.type + ".modification.withOther.hack -  px: " + that.promptIdx);
                return;
            }
        }
        if(that.appearance === 'grid') {
            //Make selection more reponsive by providing visual feedback before
            //the template is re-rendered.
            that.$('.grid-select-item.ui-bar-e').removeClass('ui-bar-e').addClass('ui-bar-c');
            that.$('input:checked').closest('.grid-select-item').addClass('ui-bar-e');
        }
        var formValue = (that.$('form').serializeArray());

        // set the value early...
        // if an earlier event fails that's OK.
        // The user intended to make this change, so it
        // is fine to be out-of-order.
        //
        // If the change is applied with an earlier change
        // then the value has been persisted. If it
        // has not yet been persisted, it will be queued and
        // applied when the user corrects whatever error
        // they had that caused the earlier action to fail.
        //
        that.setValueDeferredChange(that.generateSaveValue(formValue));
        that.updateRenderValue(formValue);

        // Here we don't want to enqueueTriggeringContext - we will include the evt in case a screen redraw is necessary
        odkCommon.log('D',"prompts." + that.type + ".modification: reRender", "px: " + that.promptIdx);
        that.reRender(evt);
    },
    configureRenderContext: function(ctxt) {
        var that = this;
        var newctxt = $.extend({}, ctxt, {success: function(outcome) {
            ctxt.log('D',"prompts." + that.type + ".configureRenderContext." + outcome,
                        "px: " + that.promptIdx);
            that.updateRenderValue(that.parseSaveValue(that.getValue()));
            ctxt.success();
        },
        failure:function(m) {
            ctxt.failure(m);
        }});

         var populateChoicesViaQueryUsingLinkedTable = function(query, newctxt){
            newctxt.log('D',"prompts." + that.type + ".configureRenderContext", "px: " + that.promptIdx);
            that.getlinkedModel($.extend({},newctxt,{success:function(linkedModel) {
                var dbTableName = linkedModel.table_id;
                var selString = that.convertSelection(linkedModel);
                var selArgs = query.selectionArgs();
                var ordBy = that.convertOrderBy(linkedModel);
                var displayElementName = that.getLinkedInstanceName();
                database.get_linked_instances($.extend({},newctxt,{success:function(instanceList) {
                    that.renderContext.choices = _.map(instanceList, function(instance) {
                        instance.display = { title: { text: instance.display_field } };
                        instance.data_value = instance.instance_id;
                        return instance;
                    });
                    newctxt.success();
                }}), dbTableName, selString, selArgs, displayElementName, ordBy);
            }}));
        };

        var populateChoicesViaQuery = function(query, newctxt){
            if (query.query_type == 'csv' || query.query_type == 'ajax')
            {
                that.populateChoicesViaQueryUsingAjax(query, newctxt);
            }
            else if (query.query_type == 'linked_table')
            {
                populateChoicesViaQueryUsingLinkedTable(query, newctxt);
            }
            else
            {
                newctxt.failure({message: "Error: undefined query type - a query in the queries sheet must have a query_type"});
            }
        };

        that.renderContext.passiveError = null;
        var queryDefn = opendatakit.getQueriesDefinition(that.values_list);
        var choiceListDefn = opendatakit.getChoicesDefinition(that.values_list);
        if(queryDefn !== null && queryDefn !== undefined) {
            populateChoicesViaQuery(queryDefn, newctxt);
        } else if (choiceListDefn !== null && choiceListDefn !== undefined) {
            //Very important.
            //We need to clone the choices so their values are unique to the prompt.
            that.renderContext.choices = _.map(choiceListDefn, _.clone);
            newctxt.success("choiceList.success");
        } else {
            newctxt.failure({message: "Error fetching choices -- no ajax query or choices defined"});
        }
    },
    deselect: function(evt) {
        odkCommon.log('D',"prompts." + this.type + ".deselect px: " + this.promptIdx);
        this.$('input:checked').prop('checked', false).change();
    }
});
promptTypes.select_one = promptTypes.select.extend({
    renderContext: {
        "select_one": true
    },
    generateSaveValue: function(jsonFormSerialization) {
        var selectedValue, otherValue;
        var promptName = this.name;
        if(jsonFormSerialization) {
            selectedValue = _.find(jsonFormSerialization, function(valueObject) {
                return (promptName === valueObject.name);
            });
            if(selectedValue) {
                if(this.withOther) {
                    if(selectedValue.value === 'other') {
                        otherValue = _.find(jsonFormSerialization, function(valueObject) {
                            return ('otherValue' === valueObject.name);
                        });
                        if (otherValue !== null &&
                            otherValue !== undefined &&
                            otherValue.value !== null &&
                            otherValue.value !== undefined &&
                            otherValue.value.length !== 0) {
                            return otherValue.value;
                        } else {
                            // We need to store a space since null values
                            // are not allowed in the database
                            return ' ';
                        }
                    }
                }
                return selectedValue.value;
            }
        }
        return null;
    },
    /**
     * Parse a saved string value into the format
     * returned by jQuery's serializeArray function.
     */
    parseSaveValue: function(savedValue){
        //Note that this function expects to run after renderContext.choices
        //has been initilized.
        var valInChoices = false;
        if(!_.isString(savedValue)) {
            return null;
        }
        if(this.renderContext.choices) {
            valInChoices = _.any(this.renderContext.choices, function(choice){
                return (choice.data_value === savedValue);
            });
        }
        if (valInChoices) {
            return [{
                "name": this.name,
                "value": savedValue
            }];
        }
        else {
            return [{
                "name": this.name,
                "value": "other"
            }, {
                "name": "otherValue",
                "value": savedValue
            }];
        }
    }
});
promptTypes.select_one_integer = promptTypes.select_one.extend({
    modification: function(evt) {
        var that = this;
        odkCommon.log('D',"prompts." + that.type + ".modification px: " + that.promptIdx + " val: " + $(evt.target).attr('value'));
        if(this.withOther) {
            //This hack is needed to prevent rerendering
            //causing the other input to loose focus when clicked.
            if( $(evt.target).val() === 'other' &&
                $(evt.target).prop('checked') &&
                //The next two lines determine if the checkbox was already checked.
                this.renderContext.other &&
                this.renderContext.other.checked) {
                odkCommon.log('D',"prompts." + this.type + ".modification.withOther.hack px: " + this.promptIdx);
                return;
            }
        }
        if(this.appearance === 'grid') {
            //Make selection more reponsive by providing visual feedback before
            //the template is re-rendered.
            this.$('.grid-select-item.ui-bar-e').removeClass('ui-bar-e').addClass('ui-bar-c');
            this.$('input:checked').closest('.grid-select-item').addClass('ui-bar-e');
        }
        var formValue = (this.$('form').serializeArray());
        // cast all values in formValue to ints
        for (var i = 0; i < formValue.length; i++) {
            formValue[i].value = parseInt(formValue[i].value);
        }

        // set the value early...
        // if an earlier event fails that's OK.
        // The user intended to make this change, so it
        // is fine to be out-of-order.
        //
        // If the change is applied with an earlier change
        // then the value has been persisted. If it
        // has not yet been persisted, it will be queued and
        // applied when the user corrects whatever error
        // they had that caused the earlier action to fail.
        //
        that.setValueDeferredChange(that.generateSaveValue(formValue));
        that.updateRenderValue(formValue);

        // Just dynamically reRender
        ctxt.log('D',"prompts." + that.type + ".modification: reRender", "px: " + that.promptIdx);
        that.reRender(evt);
    },
    /**
     * Parse a saved string value into the format
     * returned by jQuery's serializeArray function.
     */
    parseSaveValue: function(savedValue){
        //Note that this function expects to run after renderContext.choices
        //has been initilized.
        var valInChoices = false;
        if(!_.isNumber(savedValue)) {
            return null;
        }
        if(this.renderContext.choices) {
            valInChoices = _.any(this.renderContext.choices, function(choice){
                return (choice.data_value === savedValue);
            });
        }
        if (valInChoices) {
            return [{
                "name": this.name,
                "value": savedValue
            }];
        }
        else {
            return [{
                "name": this.name,
                "value": "other"
            }, {
                "name": "otherValue",
                "value": savedValue
            }];
        }
    }
});
//TODO:
//Since multiple choices are possible should it be possible
//to add arbitrary many other values to a select_with_other?
promptTypes.select_with_other = promptTypes.select.extend({
    withOther: true
});
promptTypes.select_multiple = promptTypes.select.extend({
});
promptTypes.select_one_with_other = promptTypes.select_one.extend({
    withOther: true
});
promptTypes.select_one_grid = promptTypes.select_one.extend({
    templatePath: "templates/select_grid.handlebars",
    updateRenderValue: function(formValue) {
        var that = this;
        //that.renderContext.value = formValue;
        var filteredChoices = _.filter(that.renderContext.choices, function(choice) {
            return that.choice_filter(choice);
        });

        filteredChoices = _.map(filteredChoices, function(choice, idx) {
            var columns = 3;
            choice.colLetter = String.fromCharCode(97 + (idx % columns));
            choice.isFirstInRow = false;
            choice.isLastInRow = false;
            if (idx % 3 === 0) {
                choice.isFirstInRow = true;
            }
            if (idx % 3 === 2) {
                choice.isLastInRow = true;
            }
            return choice;
        });

        if ( !formValue ) {
            that.renderContext.choices = _.map(filteredChoices, function(choice) {
                choice.checked = false;
                return choice;
            });
            if(this.withOther) {
                that.renderContext.other = null;
            }
            return;
        }
        //Check appropriate choices based on formValue
        that.renderContext.choices = _.map(filteredChoices, function(choice) {
            choice.checked = _.any(formValue, function(valueObject) {
                return choice.data_value === valueObject.value;
            });
            return choice;
        });
        if(this.withOther) {
            var otherObject = _.find(formValue, function(valueObject) {
                return ('otherValue' === valueObject.name);
            });
            that.renderContext.other = {
                value: otherObject ? otherObject.value : ' ',
                checked: _.any(formValue, function(valueObject) {
                    return ('other' === valueObject.value);
                })
            };
        }
    }
});
promptTypes.select_one_inline = promptTypes.select_one.extend({
    templatePath: "templates/select_inline.handlebars"
});
promptTypes.select_one_dropdown = promptTypes.select_one.extend({
    templatePath: "templates/select_dropdown.handlebars",
});
promptTypes.select_multiple_grid = promptTypes.select_multiple.extend({
    templatePath: "templates/select_grid.handlebars",
    updateRenderValue: function(formValue) {
        var that = this;
        //that.renderContext.value = formValue;
        var filteredChoices = _.filter(that.renderContext.choices, function(choice) {
            return that.choice_filter(choice);
        });

        filteredChoices = _.map(filteredChoices, function(choice, idx) {
            var columns = 3;
            choice.colLetter = String.fromCharCode(97 + (idx % columns));
            choice.isFirstInRow = false;
            choice.isLastInRow = false;
            if (idx % 3 === 0) {
                choice.isFirstInRow = true;
            }
            if (idx % 3 === 2) {
                choice.isLastInRow = true;
            }
            return choice;
        });

        if ( !formValue ) {
            that.renderContext.choices = _.map(filteredChoices, function(choice) {
                choice.checked = false;
                return choice;
            });
            if(this.withOther) {
                that.renderContext.other = null;
            }
            return;
        }
        //Check appropriate choices based on formValue
        that.renderContext.choices = _.map(filteredChoices, function(choice) {
            choice.checked = _.any(formValue, function(valueObject) {
                return choice.data_value === valueObject.value;
            });
            return choice;
        });
        if(this.withOther) {
            var otherObject = _.find(formValue, function(valueObject) {
                return ('otherValue' === valueObject.name);
            });
            that.renderContext.other = {
                value: otherObject ? otherObject.value : '',
                checked: _.any(formValue, function(valueObject) {
                    return ('other' === valueObject.value);
                })
            };
        }
    }
});
promptTypes.select_multiple_inline = promptTypes.select_multiple.extend({
    templatePath: "templates/select_inline.handlebars"
});
promptTypes.input_type = promptTypes.base.extend({
    type: "input_type",
    templatePath: "templates/input_type.handlebars",
    inputAttributes: {
        'placeholder':'not specified'
    },
    displayed: false,
    modified: false,
    renderContext: {
        "type": "input_type"
    },
    events: {
        "change input": "modification",
        "swipeleft .input-container": "stopPropagation",
        "swiperight .input-container": "stopPropagation",
        "focusout .input-container": "loseFocus",
        "focusin .input-container": "gainFocus"
    },
    reRender: function(evt) {
        var that = this;
        var conIdx = that.getContainerId();
        var screenRedraw = that._screen.havePromptsOnScreenChanged(that.promptIdx);
        if (screenRedraw) {
            // Need to create a context here since
            // screen reRender requires a valid context
            var ctxt = that.controller.newContext(evt, that.type + ".reRender");
            that.controller.enqueueTriggeringContext($.extend({}, ctxt, {
                success: function() {
                    odkCommon.log('D', "prompts." + that.type + ".reRender: _screen.reRender", "px: " + that.promptIdx);
                    that._screen.reRender(ctxt);
                },
                failure: function(m) {
                    odkCommon.log('D', "prompts." + that.type + ".reRender: -- prior event terminated with an error -- aborting", "px: " + that.promptIdx);
                    ctxt.failure(m);
                }
            }));

        } else {
            that._render();
            if(!that.$el){
                console.error("render px: " + that.promptIdx +
                " Prompts must have synchronous render functions. " +
                "Don't debounce them or launch async calls before el is set.");
                console.error(that);
                alert("Sub-prompt has not been rendered. See console for details.");
            }

            var $container = that._screen.$(that.getContainerId());
            $container.html(that.$el);
        }
    },
    loseFocus: function(evt) {
        var that = this;
        odkCommon.log('D',"prompts." + that.type + ".focusout px: " + that.promptIdx);

        // if renderContext is invalid, don't rerender
        if (that.modified === true && (that.renderContext.invalid !== undefined && !that.renderContext.invalid)) {
            // Here again we are just going to dynamically reRender and not enqueue a triggering context
            odkCommon.log('D',"prompts." + that.type + ".loseFocus: reRender", "px: " + that.promptIdx);
            // We may need to reRender the entire screen if there are dependent promtps
            // so let's pass in the event - from that we can create a triggering context if needed
            that.reRender(evt);
        }
    },
    gainFocus: function(evt) {
        var that = this;
        odkCommon.log('D',"prompts." + that.type + ".focusin px: " + that.promptIdx);
    },
    modification: function(evt) {
        var value = $(evt.target).val();
        var that = this;
        that.modified = false;
        if ( that.lastEventTimestamp == evt.timeStamp ) {
            odkCommon.log("D","prompts." + that.type + ".modification duplicate event ignored");
            return;
        }
        that.lastEventTimestamp = evt.timeStamp;
        odkCommon.log("D","prompts." + that.type + ".modification event being processed");
        var renderContext = that.renderContext;
        // track original value
        renderContext.invalid = that.setValueAndValidate(value);
        that.modified = true;
        renderContext.value = value;
    },
    configureRenderContext: function(ctxt) {
        var that = this;
        var renderContext = that.renderContext;
        var value = that.getValue();
        renderContext.value = value;
        if (ctxt.render === true) {
            that.displayed = true;
        }
        ctxt.success();
    },
    beforeMove: function() {
        var that = this;

        var input = this.el.getElementsByTagName('input')[0];
        // check validity with html form data validation to block screen move
        var isInvalid = (input.validity && !input.validity.valid) || that.setValueAndValidate(input.value);
        if ( isInvalid ) {
            return { message: that.display.invalid_value_message };
        } else {
            return null;
        }
    },
    setValueAndValidate: function(value) {
        var that = this;
        var originalValue = that.getValue();
        that.setValueDeferredChange((value.length === 0 ? null : value));
        var invalid = !that.validateValue();
        if ( invalid ) {
            value = originalValue;
            // restore it...
            that.setValueDeferredChange(originalValue);
        }
        return invalid;
    },
    validateValue: function() {
        return true;
    }
});
promptTypes.textarea = promptTypes.input_type.extend({
    type: "textarea",
    templatePath: "templates/textarea.handlebars",
    renderContext: {
        "type": "textarea"
    },
    beforeMove: function() {
        var that = this;
        var isInvalid = that.setValueAndValidate(this.$('textarea').val());
        if ( isInvalid ) {
            return { message: that.display.invalid_value_message };
        } else {
            return null;
        }
    }
});
promptTypes.string = promptTypes.input_type.extend({
    type: "string",
    renderContext: {
        "type": "string"
    }
});
promptTypes.text = promptTypes.input_type.extend({
    type: "text",
    renderContext: {
        "type": "text"
    }
});
promptTypes.integer = promptTypes.input_type.extend({
    type: "integer",
    templatePath: "templates/integer.handlebars",
    _baseInputAttributes: {
        'type':'number'
    },
	_protoDisplay: {
		invalid_value_message: 'invalid_integer_message'
	},
    configureRenderContext: function(ctxt) {
        var that = this;
        var renderContext = that.renderContext;
        var value = that.getValue();
        renderContext.value = value;
        renderContext.isSlider = (that.inputAttributes && that.inputAttributes.type === "range");
        // calculate width of value-box, based on max possible size of string (dynamic resizing would be bad)
        if (renderContext.isSlider) {
            var longestNum = that.inputAttributes.max.toString().length >= that.inputAttributes.min.toString().length ? that.inputAttributes.max : that.inputAttributes.min;
            renderContext.boxWidth = formulaFunctions.width(longestNum) + 20; // +20 for padding
        }

        if (ctxt.render === true) {
            that.displayed = true;
        }
        ctxt.success();
    },
    modification: function(evt) {
        var that = this;

        var value = evt.target.value;
        that.modified = false;
        if ( that.lastEventTimestamp == evt.timeStamp ) {
            odkCommon.log("D","prompts." + that.type + ".modification duplicate event ignored");
            return;
        }
        that.lastEventTimestamp = evt.timeStamp;
        odkCommon.log("D","prompts." + that.type + ".modification event being processed");
        var isSlider = (that.inputAttributes && that.inputAttributes.type === "range");
        if (isSlider) {
            var valueBox = document.getElementById("value-" + that.getPromptId());
            valueBox.innerHTML = value;
        }
        var renderContext = that.renderContext;
        // check that input is valid then setValue and validate
        renderContext.invalid = !evt.target.validity.valid || that.setValueAndValidate(value);
        that.modified = true;
        renderContext.value = value;
    },
    validateValue: function() {
        var value = this.getValue();
        if ( value === null) {
            // Null values are now respected
            return true;
        } else {
            return !isNaN(parseInt(value, 10));
        }
    }
});
promptTypes.decimal = promptTypes.input_type.extend({
    type: "decimal",
    //TODO: This doesn't seem to be working.
    _baseInputAttributes: {
        'type':'number'
    },
	_protoDisplay: {
		invalid_value_message: 'invalid_numeric_message'
	},
    validateValue: function() {
        var value = this.getValue();
        if (value === null) {
            // Null values are now respected
            return true;
        } else {
        return !isNaN(parseFloat(this.getValue()));
        }
    }
});
promptTypes.datetime = promptTypes.input_type.extend({
    type: "datetime",
    templatePath: "templates/datetimepicker.handlebars",
    // TODO: Use a template?
    usePicker: true,
    insideAfterRender: false,
    timeFormat: "MM/DD/YYYY h:mm A",
    timeTemplate: "YYYY / MM / DD  HH : mm",
    showDate: true,
    showTime: true,
    dtp: null,
    events: {
        "swipeleft input": "stopPropagation",
        "swiperight input": "stopPropagation",
        "change input": "modification"
    },
    loseFocus: function(evt) {
        var that = this;
        odkCommon.log('D',"prompts." + that.type + ".focusout px: " + that.promptIdx);

        if (that.modified === true) {
            var ctxt = that.controller.newContext(evt, that.type + ".loseFocus");
            that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
                ctxt.log('D',"prompts." + that.type + ".loseFocus: reRender", "px: " + that.promptIdx);
                that.reRender(ctxt);
            },
            failure:function(m) {
                ctxt.log('D',"prompts." + that.type + ".loseFocus -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
                ctxt.failure(m);
            }}));
        }
    },
    detectNativeDatePicker: function (){
        //For now never use the native datepicker because the samsung note's
        //native datepicker causes the webkit to freeze in some cases.
        return false;
        /*
        //It may be best to user modernizr for this type of functionality.
        var input = document.createElement('input');
        input.setAttribute('type', this.type);
        //See if the date/time type is allowed.
        if(input.type === this.type){
            //See if the input can hold non-date/time values.
            input.value = 'test';
            if (input.value !== 'test') {
                return true;
            }
        }
        return false;
        */
    },
    sameValue: function(ref, value) {
        if (ref.valueOf() != value.valueOf()) {
            return false;
        } else {
            return true;
        }
    },
    configureRenderContext: function(ctxt) {
        var that = this;
        var renderContext = that.renderContext;
        if(that.detectNativeDatePicker()){
            renderContext.inputAttributes.type = that.type;
            that.usePicker = false;
            ctxt.success();
        } else {
            var dateValue = that.getValue();
            var userTimeFormat  = renderContext.inputAttributes.timeFormat;
            if (userTimeFormat !== null && userTimeFormat !== undefined) {
                that.timeFormat = userTimeFormat;
            }
            if (dateValue !== undefined && dateValue !== null) {
                renderContext.value = moment(dateValue).format(that.timeFormat);
            }
            ctxt.success();
        }
    },
    // Due to presentation of datetime widget
    // require a full redraw not just replacing the prompt
    reRender: function(ctxt) {
        this._screen.reRender(ctxt);
    },
    modification: function(evt) {
        var that = this;
        odkCommon.log('D',"prompts." + that.type + ".modification px: " + that.promptIdx);
        if ( !that.insideAfterRender ) {
            var formattedDateValue = that.$('input').combodate('getValue', null);
            var value = null;
            if (formattedDateValue !== null && formattedDateValue !== undefined && !(_.isEmpty(formattedDateValue))) {
                if (that.type === "time") {
                    var newDate = new Date();
                    formattedDateValue.year(newDate.getUTCFullYear());
                    formattedDateValue.month(newDate.getUTCMonth());
                    formattedDateValue.date(newDate.getUTCDate());
                }
                value = new Date(formattedDateValue);
            }
            
            //
            // we are using a date pop-up.  If an earlier action fails, we should not
            // attempt to apply the state changes of this pop-up. Tolerate the loss
            // of whatever the user tried to pick. They shouldn't move so fast.

            var ctxt = that.controller.newContext(evt, that.type + ".modification");
            that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {

                odkCommon.log('D',"prompts." + that.type + ".modification: determine if reRendering ", "px: " + that.promptIdx);
                var ref = that.getValue();

                var rerender = false;
                if ( ref === null || ref === undefined ) {
                    rerender = ( value !== null && value !== undefined );
                } else if ( value === null || value === undefined ) {
                    rerender = ( ref !== null && ref !== undefined );
                } else {
                    rerender = !(that.sameValue(ref, value));
                }

                var renderContext = that.renderContext;
                if ( value === undefined || value === null ) {
                    renderContext.value = '';
                } else {
                    renderContext.value = formattedDateValue;
                }

                // track original value
                var originalValue = that.getValue();
                that.setValueDeferredChange(value);
                renderContext.invalid = !that.validateValue();
                if ( renderContext.invalid ) {
                    value = originalValue;
                    formattedDateValue = moment(value).format(that.timeFormat);
                    // restore it...
                    that.setValueDeferredChange(originalValue);
                    rerender = true;
                }

                renderContext.value = formattedDateValue;
                if ( rerender ) {
                    odkCommon.log('D',"prompts." + that.type + ".modification: reRender", "px: " + that.promptIdx);
                    that.reRender(ctxt);
                }  else {
                    // We are now done with this
                    ctxt.success();
                }
            },
            failure:function(m) {
                ctxt.log('D',"prompts." + that.type + ".modification -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
                ctxt.failure(m);
            }}));
        }
    },
    afterRender: function() {
        var that = this;
        if(that.usePicker){
            that.insideAfterRender = true;

            if (that.dtp !== null && that.dtp !== undefined) {
                that.dtp.destroy();
            }

            that.$('input').combodate({format: this.timeFormat, template: this.timeTemplate});
            
            var inputElement = that.$('input');
            that.dtp = inputElement.data('DateTimePicker');

            that.insideAfterRender = false;
        }
    },
    beforeMove: function() {
        // the spinner will have already saved the value
        // destroy the combodate if it is still present
        var that = this;

        if (that.dtp) {
            that.dtp.destroy();
        }
        return null;
    }
});
promptTypes.date = promptTypes.datetime.extend({
    type: "date",
    showTime: false,
    timeFormat: "MM/DD/YYYY",
    timeTemplate: "YYYY / MM / DD"
});

promptTypes.birthdate = promptTypes.date.extend({
    type: "birthdate",
    afterRender: function() {
        var that = this;
        if(that.usePicker){
            that.insideAfterRender = true;

            if (that.dtp !== null && that.dtp !== undefined) {
                that.dtp.destroy();
            }

            that.$('input').combodate({format: this.timeFormat, template: this.timeTemplate, maxYear: new Date().getFullYear()});
            
            var inputElement = that.$('input');
            that.dtp = inputElement.data('DateTimePicker');

            that.insideAfterRender = false;
        }
    },
});

promptTypes.time = promptTypes.datetime.extend({
    type: "time",
    showDate: false,
    timeFormat: "h:mm A",
    timeTemplate: "HH : mm",
    sameValue: function(ref, value) {
        // these are milliseconds relative to Jan 1 1970...
        var ref_tod = (ref.valueOf() % 86400000);
        var value_tod = (value.valueOf() % 86400000);
        return (ref_tod === value_tod);
    }
});
/**
 * Media is an abstract object used as a base for image/audio/video
 */
promptTypes.media = promptTypes.base.extend({
    type: "media",
    captureAction: null, // overridden by derived classes -- the intent to fire
    chooseAction: null, // overridden by derived classes -- the intent to fire
    events: {
        "click .captureAction:enabled": "capture",
        "click .chooseAction:enabled": "choose"
    },
    configureRenderContext: function(ctxt) {
        var that = this;
        that.updateRenderContext();
        ctxt.success();
    },
    disableButtons: function() {
        var that = this;
        that.$('.captureAction').prop('disabled', true);
        that.$('.chooseAction').prop('disabled', true);
    },
    enableButtons: function() {
        var that = this;
        that.$('.captureAction').prop('disabled', false);
        that.$('.chooseAction').prop('disabled', false);
    },
    capture: function(evt) {
        var that = this;
        that.disableButtons();
        var platInfo = opendatakit.getPlatformInfo();
        // TODO: is this the right sequence?
        var dispatchStruct = {promptPath: that.getPromptPath(), userAction: 'capture'};

        var mediaUri = that.getValue();

        var outcome = odkSurvey.fileAttachmentAction(dispatchStruct,
			that.captureAction,
			opendatakit.getCurrentTableId(),
			opendatakit.getCurrentInstanceId(), mediaUri);

        odkCommon.log('D',"prompts." + that.type + ".capture - doAction: " +  platInfo.container + " outcome is " + outcome);
        if (outcome === null || outcome !== "OK") {
            odkCommon.log('W',"prompts." + that.type + ".capture - doAction cancelled -- Should be OK got >" + outcome + "<");
            that.enableButtons();
        } else {
            odkCommon.log('W',"prompts." + that.type + ".capture - doAction in play -- awaiting responseAvailable");
        }
    },
    choose: function(evt) {
        var that = this;
        that.disableButtons();
        var platInfo = opendatakit.getPlatformInfo();
        // TODO: is this the right sequence?
        var dispatchStruct = {promptPath: that.getPromptPath(), userAction: 'choose'};

        var mediaUri = that.getValue();

        var outcome = odkSurvey.fileAttachmentAction(dispatchStruct,
			that.chooseAction,
			opendatakit.getCurrentTableId(),
			opendatakit.getCurrentInstanceId(), mediaUri);

        odkCommon.log('D',"prompts." + that.type + ".choose - doAction: " +  platInfo.container + " outcome is " + outcome);
        if (outcome === null || outcome !== "OK") {
            odkCommon.log('W',"prompts." + that.type + ".choose - doAction cancelled -- Should be OK got >" + outcome + "<");
            that.enableButtons();
        } else {
            odkCommon.log('W',"prompts." + that.type + ".choose - doAction in play -- awaiting responseAvailable");
        }
    },
    // TODO: support deletion of the media files??
    getCallback: function(promptPath) {
        var that = this;
        if ( that.getPromptPath() != promptPath ) {
            throw new Error("Promptpath does not match: " + promptPath + " vs. " + that.getPromptPath());
        }
        return function(ctxt, internalPromptContext, action, jsonObject) {
            ctxt.log('D',"prompts." + that.type + 'getCallback.actionFn', "px: " + that.promptIdx +
                " promptPath: " + promptPath + " internalPromptContext: " + internalPromptContext + " action: " + action);
            if (jsonObject.status === -1 /* Activity.RESULT_OK */ ) {
                ctxt.log('D',"prompts." + that.type + 'getCallback.actionFn.resultOK', "px: " + that.promptIdx +
                    " promptPath: " + promptPath + " internalPromptContext: " + internalPromptContext + " action: " + action);
                var uriFragment = (jsonObject.result !== null && jsonObject.result !== undefined) ? jsonObject.result.uriFragment : null;
                var contentType = (jsonObject.result !== null && jsonObject.result !== undefined) ? jsonObject.result.contentType : null;
                if (uriFragment !== null && uriFragment !== undefined && contentType !== null && contentType !== undefined) {
					// for debugging so we can see what we are replacing...
                    var oldMediaStruct = that.getValue();
                    var newPath = opendatakit.getRowpathFromUriFragment(uriFragment);
                    // TODO: delete old??? Or leave until marked as finalized?
                    that.setValueDeferredChange({ uriFragment : newPath, contentType: contentType });
                }
                // TODO: should null returns indicate a clearing of this value?
                that.enableButtons();
                that.updateRenderContext();
                that.reRender(ctxt);
            }
            else {
                ctxt.log('W',"prompts." + that.type + 'getCallback.actionFn.failureOutcome',
                    "px: " + that.promptIdx +
                    " failure returned from intent" +
                    " promptPath: " + promptPath + " internalPromptContext: " + internalPromptContext + " action: " + action);
                that.enableButtons();
                that.updateRenderContext();
                that.reRender($.extend({}, ctxt, {success: function() {
                    ctxt.failure({message: "Action canceled."});
                }, failure: function(j) { ctxt.failure({message: "Action canceled."});}}));
            }
        };
    },
    baseUpdateRenderContext: function() {
        var that = this;
        var mediaUri = that.getValue();
        var uriFragment = (mediaUri !== null && mediaUri !== undefined &&
                    mediaUri.uriFragment !== null && mediaUri.uriFragment !== undefined) ? mediaUri.uriFragment : null;
        var uri = (uriFragment === null || uriFragment === undefined) ? null : opendatakit.getUriFromRowpath(uriFragment);
        var contentType = (mediaUri !== null && mediaUri !== undefined &&
                    mediaUri.contentType !== null && mediaUri.contentType !== undefined) ? mediaUri.contentType : null;
        var safeIdentity = 'T'+opendatakit.genUUID().replace(/[-:]/gi,'');
        var platinfo = opendatakit.getPlatformInfo();
        if ( platinfo.container !== 'Android' ) {
            that.renderContext.pre4Android = false;
        } else {
            that.renderContext.pre4Android = ( platinfo.version.substring(0,1) < "4" );
        }
        that.renderContext.mediaPath = uri;
        that.renderContext.uriFragmentValue = uriFragment;
        that.renderContext.safeIdentity = safeIdentity;
        that.renderContext.contentType = contentType;
    },
    updateRenderContext: function() {
        this.baseUpdateRenderContext();
    },
    formattedValueForContentsDisplay: function() {
        if ( !this.name ) {
            return '';
        } else {
            var displayObject = this.getValue();
            if (displayObject !== null && displayObject !== undefined &&
                displayObject.uriFragment !== null && displayObject.uriFragment !== undefined) {
                return displayObject.uriFragment;
            }
            else {
                return '';
            }
        }
    },
    getValue: function() {
        if (!this.name) {
            console.error("prompts.media.getValue: Cannot get value of prompt with no name. px: " +
                          this.promptIdx);
            throw new Error("Cannot get value of prompt with no name.");
        }
        var value = database.getDataValue(this.name);
        if (value === null || value === undefined) {
          return null;
        }
        if (value.uriFragment === null || value.uriFragment === undefined) {
            return null;
        }
        return value;
    }
});
promptTypes.read_only_image = promptTypes.media.extend({
    type: "read_only_image",
    extension: "jpg",
    contentType: "image/*",
	_protoDisplay: {
		invalid_value_message: 'invalid_value_message' },
    templatePath: "templates/read_only_image.handlebars",
});
promptTypes.image = promptTypes.media.extend({
    type: "image",
    extension: "jpg",
    contentType: "image/*",
	_protoDisplay: {
		invalid_value_message: 'invalid_value_message',
		new_button_label: 'take_image_button_label',
	    pick_button_label: 'choose_image_button_label' },
    templatePath: "templates/image.handlebars",
    captureAction: 'org.opendatakit.survey.activities.MediaCaptureImageActivity',
    chooseAction: 'org.opendatakit.survey.activities.MediaChooseImageActivity'
});
promptTypes.signature = promptTypes.media.extend({
    type: "signature",
    extension: "jpg",
    contentType: "image/*",
	_protoDisplay: {
		invalid_value_message: 'invalid_value_message',
		new_button_label: 'take_signature_button_label' },
    templatePath: "templates/signature.handlebars",
    captureAction: 'org.opendatakit.survey.activities.SignatureActivity'
});
promptTypes.video = promptTypes.media.extend({
    type: "video",
    contentType: "video/*",
	_protoDisplay: {
		invalid_value_message: 'invalid_value_message',
		new_button_label: 'take_video_button_label',
	    pick_button_label: 'choose_video_button_label' },
    templatePath: "templates/video.handlebars",
    captureAction: 'org.opendatakit.survey.activities.MediaCaptureVideoActivity',
    chooseAction: 'org.opendatakit.survey.activities.MediaChooseVideoActivity'
});
promptTypes.audio = promptTypes.media.extend({
    type: "audio",
    contentType: "audio/*",
	_protoDisplay: {
		invalid_value_message: 'invalid_value_message',
		new_button_label: 'take_audio_button_label',
	    pick_button_label: 'choose_audio_button_label' },
    templatePath: "templates/audio.handlebars",
    captureAction: 'org.opendatakit.survey.activities.MediaCaptureAudioActivity',
    chooseAction: 'org.opendatakit.survey.activities.MediaChooseAudioActivity'
});
/**
 * launch_intent is an abstract prompt type used as a base for single intent launching (e.g. barcodes)
 * Ideally just the templates and intentStrings will need to be customized.
 */
promptTypes.launch_intent = promptTypes.base.extend({
    type: "launch_intent",
    templatePath: "templates/launch_intent.handlebars",
	_protoDisplay: {
		new_button_label: 'launch_intent_button_label' },
    intentString: "",
    intentParameters: null,//TODO: Allow this arguement to be an object {} -- note that we JSON.stringify this...,
    events: {
        "click .launch": "launch"
    },
    configureRenderContext: function(ctxt) {
        var that = this;
        var value = that.getValue();
        that.renderContext.value = value;
        ctxt.success();
    },
    launch: function(evt) {
        var that = this;
        var platInfo = opendatakit.getPlatformInfo();
        $('#block-ui').show().on('swipeleft swiperight click', function(evt) {
            evt.stopPropagation();
        });
        //We assume that the webkit could go away when an intent is launched,
        //so this prompt's "address" is passed along with the intent.
        var dispatchStruct = {promptPath: that.getPromptPath(), userAction: 'launch'};

        odkCommon.log('D',"prompts." + that.type + ".launch -- invoking doAction");
        var outcome = odkCommon.doAction( dispatchStruct, that.intentString,
            ((that.intentParameters === null || that.intentParameters === undefined) ? {} : that.intentParameters));

        odkCommon.log('D',"prompts." + that.type + ".launch - doAction: " +  platInfo.container + " outcome is " + outcome);
        if (outcome === null || outcome !== "OK") {
            odkCommon.log('W',"prompts." + that.type + ".launch - doAction cancelled -- Should be OK got >" + outcome + "<");
            $('#block-ui').hide().off();
        } else {
            odkCommon.log('W',"prompts." + that.type + ".launch - doAction in play -- awaiting responseAvailable");
        }
    },
    /**
     * When the intent returns a result this factory function creates a callback to process it.
     * The callback can't use any state set before the intent was launched because the page might have been reloaded.
     */
    getCallback: function(promptPath) {
        var that = this;
        $('#block-ui').hide().off();
        if ( that.getPromptPath() != promptPath ) {
            throw new Error("Promptpath does not match: " + promptPath + " vs. " + that.getPromptPath());
        }
        return function(ctxt, internalPromptContext, action, jsonObject) {
            ctxt.log('D',"prompts." + that.type + 'getCallback.actionFn',
                "px: " + that.promptIdx + " promptPath: " + promptPath + " internalPromptContext: " +
                internalPromptContext + " action: " + action);
            if (jsonObject.status === -1 ) { // Activity.RESULT_OK
                ctxt.log('D',"prompts." + that.type + 'getCallback.actionFn.resultOK',
                    "px: " + that.promptIdx + " promptPath: " + promptPath + " internalPromptContext: " +
                    internalPromptContext + " action: " + action);
                if (jsonObject.result !== null && jsonObject.result !== undefined) {
                    that.setValueDeferredChange(that.extractDataValue(jsonObject));
                    that.renderContext.value = that.getValue();
                    that.reRender(ctxt);
                }
            } else {
                ctxt.log('E',"prompts." + that.type + 'getCallback.actionFn.failureOutcome',
                    "px: " + that.promptIdx + " promptPath: " + promptPath + " internalPromptContext: " +
                    internalPromptContext + " action: " + action);
                ctxt.failure({message: "Action canceled."});
            }
        };
    },
    extractDataValue: function(jsonObject) {
        return jsonObject.result;
    }
});
/* Save only the SCAN_RESULT */
promptTypes.barcode = promptTypes.launch_intent.extend({
    type: "barcode",
	_protoDisplay: {
		new_button_label: 'barcode_button_label' },
    intentString: 'com.google.zxing.client.android.SCAN',
     extractDataValue: function(jsonObject) {
        return jsonObject.result.SCAN_RESULT;
    }
});
promptTypes.geopoint = promptTypes.launch_intent.extend({
    type: "geopoint",
    templatePath: "templates/geopoint.handlebars",
	_protoDisplay: {
		geopoint_latitude_component: 'geopoint_latitude_component',
		geopoint_longitude_component: 'geopoint_longitude_component',
		geopoint_altitude_component: 'geopoint_altitude_component',
		geopoint_accuracy_component: 'geopoint_accuracy_component',

		new_button_label: 'geopoint_button_label' },
    intentString: 'org.opendatakit.survey.activities.GeoPointActivity',
    extractDataValue: function(jsonObject) {
        return {
            latitude: jsonObject.result.latitude,
            longitude: jsonObject.result.longitude,
            altitude: jsonObject.result.altitude,
            accuracy: jsonObject.result.accuracy
        };
    },
    formattedValueForContentsDisplay: function() {
        if ( !this.name ) {
            return '';
        } else {
            var displayObject = this.getValue();
            if (displayObject === null || displayObject === undefined ) {
                return null;
            }
            if (displayObject.latitude !== null && displayObject.latitude !== undefined &&
                displayObject.longitude !== null && displayObject.longitude !== undefined) {
                return "lat: " + displayObject.latitude + " long: " + displayObject.longitude;
            }
            else {
                return null;
            }
        }
    },
    getValue: function() {
        if (!this.name) {
            console.error("prompts.geopoint.getValue: Cannot get value of prompt with no name. px: " +
                          this.promptIdx);
            throw new Error("Cannot get value of prompt with no name.");
        }
        var value = database.getDataValue(this.name);
        if (value === null || value === undefined) {
          return null;
        }
        if ((value.latitude === null || value.latitude === undefined) &&
            (value.longitude === null || value.longitude === undefined) &&
            (value.altitude === null || value.altitude === undefined) &&
            (value.accuracy === null || value.accuracy === undefined)) {
            return null;
        }
        return value;
    }
});
promptTypes.geopointmap = promptTypes.launch_intent.extend({
    type: "geopointmap",
    intentString: 'org.opendatakit.survey.activities.GeoPointMapActivity',
    extractDataValue: function(jsonObject) {
        return {
            latitude: jsonObject.result.latitude,
            longitude: jsonObject.result.longitude,
            altitude: jsonObject.result.altitude,
            accuracy: jsonObject.result.accuracy
        };
    },
    formattedValueForContentsDisplay: function() {
        if ( !this.name ) {
            return '';
        } else {
            var displayObject = this.getValue();
            if (displayObject === null || displayObject === undefined ) {
                return null;
            }
            if (displayObject.latitude !== null && displayObject.latitude !== undefined &&
                displayObject.longitude !== null && displayObject.longitude !== undefined) {
                return "lat: " + displayObject.latitude + " long: " + displayObject.longitude;
            }
            else {
                return null;
            }
        }
    },
    getValue: function() {
        if (!this.name) {
            console.error("prompts.geopointmap.getValue: Cannot get value of prompt with no name. px: " +
                          this.promptIdx);
            throw new Error("Cannot get value of prompt with no name.");
        }
        var value = database.getDataValue(this.name);
        if (value === null || value === undefined) {
          return null;
        }
        if ((value.latitude === null || value.latitude === undefined) &&
            (value.longitude === null || value.longitude === undefined) &&
            (value.altitude === null || value.altitude === undefined) &&
            (value.accuracy === null || value.accuracy === undefined)) {
            return null;
        }
        return value;
    }
});
promptTypes.note = promptTypes.base.extend({
    type: "note",
    templatePath: "templates/note.handlebars"
});

promptTypes.bargraph = promptTypes.base.extend({
    type: "bargraph",
    vHeight: 0,
    vWidth: 0,
    events: {
        "click .y_up": "scale_y_up",
        "click .y_down": "scale_y_down",
        "click .x_up": "scale_x_up",
        "click .x_down": "scale_x_down"
    },
    templatePath: "templates/graph.handlebars",
    scale_y_up: function(evt){
        var that = this;
        var ctxt = that.controller.newContext(evt, that.type + ".scale_y_up");
        that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
            ctxt.log('D',"prompts." + that.type + ".scale_y_up: reRender", "px: " + that.promptIdx);
            that.vHeight = that.vHeight + (that.vHeight * 0.2);
            that.reRender(ctxt);
        },
        failure:function(m) {
            ctxt.log('D',"prompts." + that.type + ".scale_y_up -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
            ctxt.failure(m);
        }}));
    },
    scale_y_down: function(evt){
        var that = this;
        var ctxt = that.controller.newContext(evt, that.type + ".scale_y_down");
        that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
            ctxt.log('D',"prompts." + that.type + ".scale_y_down: reRender", "px: " + that.promptIdx);
            that.vHeight = that.vHeight - (that.vHeight * 0.2);
            that.reRender(ctxt);
        },
        failure:function(m) {
            ctxt.log('D',"prompts." + that.type + ".scale_y_down -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
            ctxt.failure(m);
        }}));
    },
    scale_x_up: function(evt){
        var that = this;
        var ctxt = that.controller.newContext(evt, that.type + ".scale_x_up");
        that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
            ctxt.log('D',"prompts." + that.type + ".scale_x_up: reRender", "px: " + that.promptIdx);
            that.vWidth = that.vWidth + (that.vWidth * 0.2);
            that.reRender(ctxt);
        },
        failure:function(m) {
            ctxt.log('D',"prompts." + that.type + ".scale_x_up -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
            ctxt.failure(m);
        }}));
    },
    scale_x_down: function(evt){
        var that = this;
        var ctxt = that.controller.newContext(evt, that.type + ".scale_x_down");
        that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
            ctxt.log('D',"prompts." + that.type + ".scale_x_down: reRender", "px: " + that.promptIdx);
            that.vWidth = that.vWidth - (that.vWidth * 0.2);
            that.reRender(ctxt);
        },
        failure:function(m) {
            ctxt.log('D',"prompts." + that.type + ".scale_x_down -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
            ctxt.failure(m);
        }}));
    },
    configureRenderContext: function(ctxt) {
        var that = this;
        var newctxt = $.extend({}, ctxt, {success: function(outcome) {
            ctxt.log('D',"prompts." + that.type + ".configureRenderContext." + outcome,
                        "px: " + that.promptIdx);
            ctxt.success();
        },
        failure:function(m) {
            ctxt.failure(m);
        }});

        that.renderContext.passiveError = null;
        that.renderContext.graphType = that.type;
        var queryDefn = opendatakit.getQueriesDefinition(that.values_list);
        if(queryDefn !== null && queryDefn !== undefined) {
            that.populateChoicesViaQueryUsingAjax(queryDefn, newctxt);
        } else {
            newctxt.failure({message: "Error fetching choices -- no ajax query or choices defined"});
        }
    },
    afterRender: function() {
        var that = this;

        var paramWidth = 400;
        var paramHeight = 450;

        // In configureRenderContext getting data via the CSV
        // fetched data should now be in the renderContext.choices array
        if (that.renderContext.choices.length === 0)
        {
            odkCommon.log("E","prompts." + that.type + ".afterRender - no data to graph");
            return;
        }
        var dataJ = _.map(that.renderContext.choices, function(choice){
            return choice;
        });

        var margin = {top: 50, right: 20, bottom: 50, left: 50},
            width = paramWidth - margin.left - margin.right,
            height = paramHeight - margin.top - margin.bottom;

        var x = d3.scale.ordinal().rangeRoundBands([0, width], 0.1);

        var y = d3.scale.linear().range([height, 0]);

        var xAxis = d3.svg.axis()
        .scale(x)
        .orient("bottom");

        var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left")
        .tickSubdivide(true);

        dataJ.forEach(function(d) {
                d.y = +d.y;
            });

        x.domain(dataJ.map(function(d) { return d.x; }));
        y.domain([0, d3.max(dataJ, function(d) { return d.y; })]);
        if (that.vWidth === 0) {
            that.vWidth = width;
        }
        if (that.vHeight === 0) {
            that.vHeight = height;
        }

        var lMarg = 0;
        var tMarg = 0;

        var tempHeight = that.vHeight + 0;
        x.rangeRoundBands([0, that.vWidth + 0], 0.2);
        y.range([tempHeight, 0]);
        yAxis.ticks(tempHeight/30);

        that.$("#plot").bind('pinch', function(){
            that.scale_y_down();
        });

        var svg = d3.select(that.$("#plot").get(0)).append("svg")
            .attr("id", "svgElement")
            .attr("class", "wholeBody")
            .attr("z-index", 1)
            .attr("width", that.vWidth + margin.left + margin.right + 0)
            .attr("height", that.vHeight + margin.top + margin.bottom + 0)
            .append("g")
            .attr("transform", "translate(" + (margin.left + lMarg) + "," + (margin.top + tMarg) + ")");

            svg.append("g")
            .attr("class", "x-axis")
            .attr("z-index", 4)
            .attr("transform", "translate(0," + tempHeight + ")")
            .call(xAxis)
            .append("text")
            .attr("x", that.vWidth/2-50)
            .attr("y", 35)
            .attr("dx", ".71em")
            .attr("pointer-events", "all")
            .style("font-size", "1.5em")
            .style("text-anchor", "start")
            .text("x-axis");

            svg.append("g")
            .attr("class", "y_axis")
            .attr("z-index", 4)
            .call(yAxis)
            .append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", -35)
            .attr("x", -1 * tempHeight/2)
            .style("font-size", "1.5em")
            .style("text-anchor", "end")
            .text("y-axis");
             var lines = svg.selectAll(".bar")
              .data(dataJ);

          lines.enter()
            .append("rect")
              .attr("class", "bar")
              .attr("width", x.rangeBand())
              .attr("fill", function(d) {
                return 'red';// change this using d.y with 'if' statements to hard code color values
                });
          lines
              .attr("x", function(d) { return x(d.x); })
              .attr("y", function(d) { return y(d.y); })
              .attr("height", function(d) { return tempHeight - y(d.y); });

        return;
    }
});

promptTypes.linegraph = promptTypes.base.extend({
    type: "linegraph",
    vHeight: 0,
    vWidth: 0,
    events: {
        "click .y_up": "scale_y_up",
        "click .y_down": "scale_y_down",
        "click .x_up": "scale_x_up",
        "click .x_down": "scale_x_down"
    },
    templatePath: "templates/graph.handlebars",
    scale_y_up: function(evt){
        var that = this;
        var ctxt = that.controller.newContext(evt, that.type + ".scale_y_up");
        that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
            ctxt.log('D',"prompts." + that.type + ".scale_y_up: reRender", "px: " + that.promptIdx);
            that.vHeight = that.vHeight + (that.vHeight * 0.2);
            that.reRender(ctxt);
        },
        failure:function(m) {
            ctxt.log('D',"prompts." + that.type + ".scale_y_up -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
            ctxt.failure(m);
        }}));
    },
    scale_y_down: function(evt){
        var that = this;
        var ctxt = that.controller.newContext(evt, that.type + ".scale_y_down");
        that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
            ctxt.log('D',"prompts." + that.type + ".scale_y_down: reRender", "px: " + that.promptIdx);
            that.vHeight = that.vHeight - (that.vHeight * 0.2);
            that.reRender(ctxt);
        },
        failure:function(m) {
            ctxt.log('D',"prompts." + that.type + ".scale_y_down -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
            ctxt.failure(m);
        }}));
    },
    scale_x_up: function(evt){
        var that = this;
        var ctxt = that.controller.newContext(evt, that.type + ".scale_x_up");
        that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
            ctxt.log('D',"prompts." + that.type + ".scale_x_up: reRender", "px: " + that.promptIdx);
            that.vWidth = that.vWidth + (that.vWidth * 0.2);
            that.reRender(ctxt);
        },
        failure:function(m) {
            ctxt.log('D',"prompts." + that.type + ".scale_x_up -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
            ctxt.failure(m);
        }}));
    },
    scale_x_down: function(evt){
        var that = this;
        var ctxt = that.controller.newContext(evt, that.type + ".scale_x_down");
        that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
            ctxt.log('D',"prompts." + that.type + ".scale_x_down: reRender", "px: " + that.promptIdx);
            that.vWidth = that.vWidth - (that.vWidth * 0.2);
            that.reRender(ctxt);
        },
        failure:function(m) {
            ctxt.log('D',"prompts." + that.type + ".scale_x_down -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
            ctxt.failure(m);
        }}));
    },
    configureRenderContext: function(ctxt) {
        var that = this;
        var newctxt = $.extend({}, ctxt, {success: function(outcome) {
            ctxt.log('D',"prompts." + that.type + ".configureRenderContext." + outcome,
                        "px: " + that.promptIdx);
            ctxt.success();
        },
        failure:function(m) {
            ctxt.failure(m);
        }});

        that.renderContext.passiveError = null;
        that.renderContext.graphType = that.type;
        var queryDefn = opendatakit.getQueriesDefinition(that.values_list);
        if(queryDefn !== null && queryDefn !== undefined) {
            that.populateChoicesViaQueryUsingAjax(queryDefn, newctxt);
        } else {
            newctxt.failure({message: "Error fetching choices -- no ajax query or choices defined"});
        }
    },
    afterRender: function() {
        var that = this;
        var xString = "x-axis";
        var yString = "y-axis";
        var legendString = "y-value";

        var paramWidth = 450;
        var paramHeight = 400;

        // In configureRenderContext getting data via the CSV
        // fetched data should now be in the renderContext.choices array
        if (that.renderContext.choices.length === 0)
        {
            odkCommon.log("E","prompts." + that.type + ".afterRender - no data to graph");
            return;
        }

        if (that.x_axis_label) {
            xString = that.x_axis_label;
        }

        if (that.y_axis_label) {
            yString = that.y_axis_label;
        }

        if (that.legend_text) {
            legendString = that.legend_text;
        }

        var dataJ = _.map(that.renderContext.choices, function(choice){
            return choice;
        });

        var margin = {top: 50, right: 20, bottom: 40, left: 50},
            width = paramWidth - margin.left - margin.right,
            height = paramHeight - margin.top - margin.bottom;

        var x = d3.scale.linear().range([0, width]);

        var y = d3.scale.linear().range([height, 0]);

        var xAxis = d3.svg.axis()
            .scale(x)
            .orient("bottom")
            .tickSubdivide(true);

         var yAxis = d3.svg.axis()
            .scale(y)
            .orient("left")
            .tickSubdivide(true);

        dataJ.forEach(function(d) {
            d.y = +d.y;
            d.x = +d.x;
        });

        /* When dataMin and dataMax gets implemented
        dataMin.forEach(function(d) {
            d.y = +d.y;
            d.x = +d.x;
        });

        dataMax.forEach(function(d) {
            d.y = +d.y;
            d.x = +d.x;
        });
        */


        var line = d3.svg.line()
            .x(function(d) { return x(d.x); })
            .y(function(d) { return y(d.y); });

        // Don't have a dataMax of dataMin yet
        // Also setting this to a fixed range and domain for now
        // These will probably need to be settings
        x.domain([0, d3.max(dataJ, function(d) { return d.x; })]);
        y.domain([d3.min(dataJ, function(d) { return d.y; }), d3.max(dataJ, function(d) { return d.y; })]);

        if (that.vWidth === 0) {
            that.vWidth = width;
        }
        if (that.vHeight === 0) {
            that.vHeight = height;
        }

        var lMarg = 0;
        var tMarg = 0;

        var tempHeight = that.vHeight + 0;
        //x.rangeRoundBands([0, that.vWidth + 0], .2);
        x.range([0, that.vWidth]);
        y.range([tempHeight, 0]);
        yAxis.ticks(tempHeight/30);

        var svg = d3.select(that.$("#plot").get(0)).append("svg")
            .attr("id", "svgElement")
            .attr("class", "wholeBody")
            .attr("z-index", 1)
            .attr("width", that.vWidth + margin.left + margin.right + 0)
            .attr("height", that.vHeight + margin.top + margin.bottom + 0)
            .append("g")
            .attr("transform", "translate(" + (margin.left + lMarg) + "," + (margin.top + tMarg) + ")");

        svg.append("g")
            .attr("class", "x-axis")
            .attr("z-index", 4)
            .attr("transform", "translate(0," + tempHeight + ")")
            .call(xAxis)
            .append("text")
            .attr("x", that.vWidth/2-50)
            .attr("y", 35)
            .attr("dx", ".71em")
            .attr("pointer-events", "all")
            .style("font-size", "1.5em")
            .style("text-anchor", "start")
            .text(xString);  // This should be customizable

        svg.append("g")
            .attr("class", "y_axis")
            .attr("z-index", 4)
            .call(yAxis)
            .append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", -35)
            .attr("x", -1 * tempHeight/2)
            .style("font-size", "1.5em")
            .style("text-anchor", "end")
            .text(yString);  // This should be customizable

        svg.append("path")
            .datum(dataJ)
            .attr("class", "line")
            .attr("fill", "none")
            .attr("stroke", "blue")
            .attr("d", line);

        // add legend
        var legend = svg.append("g")
            .attr("class", "legend")
            .attr("height", 50)
            .attr("width", 100);

        legend
            .append("rect")
            .attr("x", -10 )
            .attr("y", -30)
            .attr("width", 10)
            .attr("height", 10)
            .style("fill", 'blue');

        legend
        .append("text")
        .attr("x", 10)
        .attr("y", -20)
        .text(legendString);

        if (that.x_value && that.y_value) {
            var x_val = database.getDataValue(that.x_value);
            var y_val = database.getDataValue(that.y_value);
            svg.append("circle")
                .attr("class", "dot")
                .attr("r", 8)
                .attr("fill", "none")
                .attr("stroke", "#0a0")
                .attr("stroke-width", "1.5px")
                .attr("cx", function(d) { return x(x_val); })
                .attr("cy", function(d) { return y(y_val); });
    }


        return;
    }
});

promptTypes.piechart = promptTypes.base.extend({
    type: "piechart",
    vHeight: 0,
    vWidth: 0,
    vRadius: 0,
    events: {
        "click .scale_up": "scale_up",
        "click .scale_down": "scale_down",
    },
    templatePath: "templates/graph.handlebars",
    scale_up: function(evt){
        var that = this;
        var ctxt = that.controller.newContext(evt, that.type + ".scale_up");
        that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
            ctxt.log('D',"prompts." + that.type + ".scale_up: reRender", "px: " + that.promptIdx);
            that.vHeight = that.vHeight + (that.vHeight * 0.1);
            that.vWidth = that.vWidth + (that.vWidth * 0.1);
            that.vRadius = that.vRadius * 1.1;
            that.reRender(ctxt);
        },
        failure:function(m) {
            ctxt.log('D',"prompts." + that.type + ".scale_up -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
            ctxt.failure(m);
        }}));
    },
    scale_down: function(evt){
        var that = this;
        var ctxt = that.controller.newContext(evt, that.type + ".scale_down");
        that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
            ctxt.log('D',"prompts." + that.type + ".scale_down: reRender", "px: " + that.promptIdx);
            that.vHeight = that.vHeight - (that.vHeight * 0.1);
            that.vWidth = that.vWidth - (that.vWidth * 0.1);
            that.vRadius = that.vRadius * 0.9;
            that.reRender(ctxt);
        },
        failure:function(m) {
            ctxt.log('D',"prompts." + that.type + ".scale_down -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
            ctxt.failure(m);
        }}));
    },
    configureRenderContext: function(ctxt) {
        var that = this;
        var newctxt = $.extend({}, ctxt, {success: function(outcome) {
            ctxt.log('D',"prompts." + that.type + ".configureRenderContext." + outcome,
                        "px: " + that.promptIdx);
            ctxt.success();
        },
        failure:function(m) {
            ctxt.failure(m);
        }});

        that.renderContext.passiveError = null;
        that.renderContext.graphType = that.type;
        var queryDefn = opendatakit.getQueriesDefinition(that.values_list);
        if(queryDefn !== null && queryDefn !== undefined) {
            that.populateChoicesViaQueryUsingAjax(queryDefn, newctxt);
        } else {
            newctxt.failure({message: "Error fetching choices -- no ajax query or choices defined"});
        }
    },
    afterRender: function() {
        var that = this;

        var paramWidth = 500;
        var paramHeight = 500;

        var margin = {top: 20, right: 20, bottom: 40, left: 80},
            width = paramWidth - margin.left - margin.right,
            height = paramHeight - margin.top - margin.bottom,
            radius = Math.min(width, height) / 2;

        // In configureRenderContext getting data via the CSV
        // fetched data should now be in the renderContext.choices array
        if (that.renderContext.choices.length === 0)
        {
            odkCommon.log("E","prompts." + that.type + ".afterRender - no data to graph");
            return;
        }
        var dataJ = _.map(that.renderContext.choices, function(choice){
            return choice;
        });

        if (that.vWidth === 0) {
            that.vWidth = width;
        }
        if (that.vHeight === 0) {
            that.vHeight = height;
        }
        if (that.vRadius === 0) {
            that.vRadius = radius;
        }

        dataJ.forEach(function(d) {
            d.y = +d.y;
        });


        var arc = d3.svg.arc()
            .outerRadius(that.vRadius - 10)
            .innerRadius(0);

        var pie = d3.layout.pie()
            .sort(null)
            .value(function(d) { return d.y; });

        var svg = d3.select(that.$("#plot").get(0)).append("svg")
            .attr("class", "wholeBody")
            .data([dataJ])
            .attr("width", that.vWidth)
            .attr("height", that.vHeight)
            .append("g")
            .attr("transform", "translate(" + that.vWidth / 2 + "," + that.vHeight / 2 + ")");

        var g = svg.selectAll(".arc")
            .data(pie(dataJ))
            .enter().append("g")
            .attr("class", "arc");

        g.append("path")
            .attr("d", arc)
            .style("fill", function(d, i) {
                // Switch to a case statement
                // Maybe these colors should be available in a library or something
                if(i === 0) {
                    return "green";
                } else if(i === 1) {
                    return "yellow";
                } else if(i === 2){
                    return "blue";
                } else if(i === 3){
                    return "red";
                } else if(i === 4){
                    return "orange";
                } else if(i === 5){
                    return "purple";
                } else if(i === 6){
                    return "pink";
                } else if(i === 7){
                    return "teal";
                }
            });

        g.append("text")
            .attr("transform", function(d) { return "translate(" + arc.centroid(d) + ")"; })
            .attr("dy", "2em")
            .style("text-anchor", "middle")
            .text(function(d, i) { return dataJ[i].x; });
    }
});

promptTypes.scatterplot = promptTypes.base.extend({
    type: "scatterplot",
    vHeight: 0,
    vWidth: 0,
    events: {
        "click .y_up": "scale_y_up",
        "click .y_down": "scale_y_down",
        "click .x_up": "scale_x_up",
        "click .x_down": "scale_x_down"
    },
    templatePath: "templates/graph.handlebars",
    scale_y_up: function(evt){
        var that = this;
        var ctxt = that.controller.newContext(evt, that.type + ".scale_y_up");
        that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
            ctxt.log('D',"prompts." + that.type + ".scale_y_up: reRender", "px: " + that.promptIdx);
            that.vHeight = that.vHeight + (that.vHeight * 0.2);
            that.reRender(ctxt);
        },
        failure:function(m) {
            ctxt.log('D',"prompts." + that.type + ".scale_y_up -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
            ctxt.failure(m);
        }}));
    },
    scale_y_down: function(evt){
        var that = this;
        var ctxt = that.controller.newContext(evt, that.type + ".scale_y_down");
        that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
            ctxt.log('D',"prompts." + that.type + ".scale_y_down: reRender", "px: " + that.promptIdx);
            that.vHeight = that.vHeight - (that.vHeight * 0.2);
            that.reRender(ctxt);
        },
        failure:function(m) {
            ctxt.log('D',"prompts." + that.type + ".scale_y_down -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
            ctxt.failure(m);
        }}));
    },
    scale_x_up: function(evt){
        var that = this;
        var ctxt = that.controller.newContext(evt, that.type + ".scale_x_up");
        that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
            ctxt.log('D',"prompts." + that.type + ".scale_x_up: reRender", "px: " + that.promptIdx);
            that.vWidth = that.vWidth + (that.vWidth * 0.2);
            that.reRender(ctxt);
        },
        failure:function(m) {
            ctxt.log('D',"prompts." + that.type + ".scale_x_up -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
            ctxt.failure(m);
        }}));
    },
    scale_x_down: function(evt){
        var that = this;
        var ctxt = that.controller.newContext(evt, that.type + ".scale_x_down");
        that.controller.enqueueTriggeringContext($.extend({},ctxt,{success:function() {
            ctxt.log('D',"prompts." + that.type + ".scale_x_down: reRender", "px: " + that.promptIdx);
            that.vWidth = that.vWidth - (that.vWidth * 0.2);
            that.reRender(ctxt);
        },
        failure:function(m) {
            ctxt.log('D',"prompts." + that.type + ".scale_x_down -- prior event terminated with an error -- aborting!", "px: " + that.promptIdx);
            ctxt.failure(m);
        }}));
    },
    configureRenderContext: function(ctxt) {
        var that = this;
        var newctxt = $.extend({}, ctxt, {success: function(outcome) {
            ctxt.log('D',"prompts." + that.type + ".configureRenderContext." + outcome,
                        "px: " + that.promptIdx);
            ctxt.success();
        },
        failure:function(m) {
            ctxt.failure(m);
        }});

        that.renderContext.passiveError = null;
        that.renderContext.graphType = that.type;
        var queryDefn = opendatakit.getQueriesDefinition(that.values_list);
        if(queryDefn !== null && queryDefn !== undefined) {
            that.populateChoicesViaQueryUsingAjax(queryDefn, newctxt);
        } else {
            newctxt.failure({message: "Error fetching choices -- no ajax query or choices defined"});
        }
    },
    afterRender: function() {
        var that = this;

        var paramWidth = 450;
        var paramHeight = 400;

        var margin = {top: 20, right: 20, bottom: 40, left: 50},
            width = paramWidth - margin.left - margin.right,
            height = paramHeight - margin.top - margin.bottom,
            padding = 30;

        if (that.vWidth === 0) {
            that.vWidth = width;
        }
        if (that.vHeight === 0) {
            that.vHeight = height;
        }

        // In configureRenderContext getting data via the CSV
        // fetched data should now be in the renderContext.choices array
        if (that.renderContext.choices.length === 0)
        {
            odkCommon.log("E","prompts." + that.type + ".afterRender - no data to graph");
            return;
        }

        var dataJ = _.map(that.renderContext.choices, function(choice){
            return choice;
        });

        dataJ.forEach(function(d) {
            d.x = +d.x;
            d.y = +d.y;
            d.r = +d.r;
        });

        var x = d3.scale.ordinal()
            .rangeRoundBands([0, that.vWidth], 0.1);

        var y = d3.scale.linear()
            .range([that.vHeight, 0]);

        x.domain([0, d3.max(dataJ, function(d) { return d.x; })]);
        y.domain([0, d3.max(dataJ, function(d) { return d.y; })]);

        //    Create scale functions
        var xScale = d3.scale.linear()
            .domain([0, d3.max(dataJ, function(d) { return d.x; })])
            .range([padding, that.vWidth - padding * 2]);

        var yScale = d3.scale.linear()
            .domain([0, d3.max(dataJ, function(d) { return d.y; })])
            .range([that.vHeight - padding, padding]);

        var rScale = d3.scale.linear()
            .domain([0, d3.max(dataJ, function(d) { return d.y; })])
            .range([2, 5]);

        // Define X axis
        var xAxis = d3.svg.axis()
            .scale(xScale)
            .orient("bottom")
            .ticks(5);

        // Define Y axis
        var yAxis = d3.svg.axis()
            .scale(yScale)
            .orient("left")
            .ticks(5);


        // Drawing
        d3.selectAll(".wholeBody").remove();

        //    Create SVG element
        var svg = d3.select(that.$("#plot").get(0))
            .append("svg")
            .attr("class", "wholeBody")
            .attr("width", that.vWidth + margin.left + margin.right)
            .attr("height", that.vHeight + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + (margin.left) + "," + (margin.top) + ")");

        x.rangeRoundBands([0, that.vWidth], 0.1);
        y.range([that.vHeight, 0]);

        yScale.range([that.vHeight - padding, padding]);
        xScale.range([padding, that.vWidth - padding * 2]);

        // For now hardcode these values for colors
        var rString = "x";
        var getForegroundColor = function(value) {
            var len = 0;
            if (value !== null && value !== undefined) {
                len = parseInt(value) / 10;
            }
            console.log('getForegroundColor() called');
            // we need to return a string, so we'll just bring back a dummy value
            var colors = ['blue','red','yellow','orange','green'];
            return colors[parseInt(len) % colors.length];
        };

        //        Create circles
        svg.selectAll("circle")
            .data(dataJ)
            .enter()
            .append("circle")
            .attr("cx", function(d) {
                return xScale(d.x);
            })
            .attr("cy", function(d) {
                return yScale(d.y);
            })
            .attr("r", function(d) {
                return rScale(4);
            })
            .attr("fill", function(d) {
                if(rString != "No Scaling") {
                    return getForegroundColor(d.r);
                } else {
                    return "black";
                }
            });

        //        Create X axis
        svg.append("g")
            .attr("class", "axis")
            .attr("transform", "translate(0," + (that.vHeight - padding) + ")")
            .call(xAxis)
            .append("text")
            .attr("x", that.vWidth/2-50)
            .attr("y", 35)
            .style("font-size", "1.5em")
            .style("text-anchor", "start")
            .text("x-axis");  // Need to be able to pass a string in

        //        Create Y axis
        svg.append("g")
            .attr("class", "axis")
            .attr("transform", "translate(" + padding + ",0)")
            .call(yAxis)
            .append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", -35)
            .attr("x", -1 * that.vHeight/2)
            .style("font-size", "1.5em")
            .style("text-anchor", "end")
            .text("y-axis");  // Need to be able to pass a string in
        }
});

// psuedo-prompt emitted by do_section so that sections appear in contents list
promptTypes._section = promptTypes.base.extend({
    type: "_section",
    templatePath: "templates/_section.handlebars"
});
promptTypes.acknowledge = promptTypes.select.extend({
    type: "acknowledge",
    autoAdvance: false,
    acknLabel:  odkCommon.lookupToken('acknLabel'),
    modification: function(evt) {
        var that = this;
        odkCommon.log('D','acknowledge.modification px: ' + that.promptIdx);
        var oldValue = that.getValue();
        var acknowledged = (oldValue !== undefined && oldValue !== null) ? !oldValue : true;

        // set the value early...
        // if an earlier event fails that's OK.
        // The user intended to click this, so it
        // is fine to be out-of-order.
        //
        // If the change is applied with an earlier change
        // then the value has been persisted. If it
        // has not yet been persisted, it will be queued and
        // applied when the user corrects whatever error
        // they had that caused the earlier action to fail.
        //
        that.setValueDeferredChange(acknowledged);

        // Now we will just try to reRender
        odkCommon.log('D',"prompts." + that.type + ".modification: reRender px: " + that.promptIdx);

        that.renderContext.choices = [{
            name: "acknowledge",
            display:{"title":{"text": that.acknLabel.text}},
            checked: acknowledged
        }];

        if (acknowledged && that.autoAdvance) {
            var ctxt = that.controller.newContext(evt, that.type + ".modification");
            that.controller.gotoNextScreen(ctxt);
        } else {
            that.reRender(evt);
        }
    },
    configureRenderContext: function(ctxt) {
        var that = this;
        var acknowledged;
        try{
            acknowledged = that.getValue();
            if ( acknowledged === undefined || acknowledged === null ) {
                acknowledged = false;
            }
        } catch(e) {
            acknowledged = false;
        }
        that.renderContext.choices = [{
            name: "acknowledge",
            display:{"title":{"text": that.acknLabel.text}},
            checked: acknowledged
        }];
        ctxt.success();
    }
});

return promptTypes;
});

